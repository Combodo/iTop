{"version":3,"file":"sifter.js","sources":["../../node_modules/@orchidjs/unicode-variants/dist/esm/regex.js","../../node_modules/@orchidjs/unicode-variants/dist/esm/strings.js","../../node_modules/@orchidjs/unicode-variants/dist/esm/index.js","../../lib/utils.ts","../../lib/sifter.ts"],"sourcesContent":["/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */\n/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n * \tex ['a','b'] => [ab]\n * @param {string[]} chars\n * @return {string}\n */\nconst arrayToPattern = chars => {\n  chars = chars.filter(Boolean);\n\n  if (chars.length < 2) {\n    return chars[0] || '';\n  }\n\n  return maxValueLength(chars) == 1 ? '[' + chars.join('') + ']' : '(?:' + chars.join('|') + ')';\n};\n/**\n * @param {string[]} array\n * @return {string}\n */\n\nconst sequencePattern = array => {\n  if (!hasDuplicates(array)) {\n    return array.join('');\n  }\n\n  let pattern = '';\n  let prev_char_count = 0;\n\n  const prev_pattern = () => {\n    if (prev_char_count > 1) {\n      pattern += '{' + prev_char_count + '}';\n    }\n  };\n\n  array.forEach((char, i) => {\n    if (char === array[i - 1]) {\n      prev_char_count++;\n      return;\n    }\n\n    prev_pattern();\n    pattern += char;\n    prev_char_count = 1;\n  });\n  prev_pattern();\n  return pattern;\n};\n/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n * \tex ['a','b'] => [ab]\n * @param {Set<string>} chars\n * @return {string}\n */\n\nconst setToPattern = chars => {\n  let array = toArray(chars);\n  return arrayToPattern(array);\n};\n/**\n *\n * https://stackoverflow.com/questions/7376598/in-javascript-how-do-i-check-if-an-array-has-duplicate-values\n * @param {any[]} array\n */\n\nconst hasDuplicates = array => {\n  return new Set(array).size !== array.length;\n};\n/**\n * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error\n * @param {string} str\n * @return {string}\n */\n\nconst escape_regex = str => {\n  return (str + '').replace(/([\\$\\(\\)\\*\\+\\.\\?\\[\\]\\^\\{\\|\\}\\\\])/gu, '\\\\$1');\n};\n/**\n * Return the max length of array values\n * @param {string[]} array\n *\n */\n\nconst maxValueLength = array => {\n  return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);\n};\n/**\n * @param {string} str\n */\n\nconst unicodeLength = str => {\n  return toArray(str).length;\n};\n/**\n * @param {any} p\n * @return {any[]}\n */\n\nconst toArray = p => Array.from(p);\n\nexport { arrayToPattern, escape_regex, hasDuplicates, maxValueLength, sequencePattern, setToPattern, toArray, unicodeLength };\n//# sourceMappingURL=regex.js.map\n","/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */\n/**\n * Get all possible combinations of substrings that add up to the given string\n * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string\n * @param {string} input\n * @return {string[][]}\n */\nconst allSubstrings = input => {\n  if (input.length === 1) return [[input]];\n  /** @type {string[][]} */\n\n  let result = [];\n  const start = input.substring(1);\n  const suba = allSubstrings(start);\n  suba.forEach(function (subresult) {\n    let tmp = subresult.slice(0);\n    tmp[0] = input.charAt(0) + tmp[0];\n    result.push(tmp);\n    tmp = subresult.slice(0);\n    tmp.unshift(input.charAt(0));\n    result.push(tmp);\n  });\n  return result;\n};\n\nexport { allSubstrings };\n//# sourceMappingURL=strings.js.map\n","/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */\nimport { toArray, setToPattern, escape_regex, arrayToPattern, sequencePattern } from './regex.js';\nexport { escape_regex } from './regex.js';\nimport { allSubstrings } from './strings.js';\n\n/**\n * @typedef {{[key:string]:string}} TUnicodeMap\n * @typedef {{[key:string]:Set<string>}} TUnicodeSets\n * @typedef {[[number,number]]} TCodePoints\n * @typedef {{folded:string,composed:string,code_point:number}} TCodePointObj\n * @typedef {{start:number,end:number,length:number,substr:string}} TSequencePart\n */\n/** @type {TCodePoints} */\n\nconst code_points = [[0, 65535]];\nconst accent_pat = '[\\u0300-\\u036F\\u{b7}\\u{2be}\\u{2bc}]';\n/** @type {TUnicodeMap} */\n\nlet unicode_map;\n/** @type {RegExp} */\n\nlet multi_char_reg;\nconst max_char_length = 3;\n/** @type {TUnicodeMap} */\n\nconst latin_convert = {};\n/** @type {TUnicodeMap} */\n\nconst latin_condensed = {\n  '/': '⁄∕',\n  '0': '߀',\n  \"a\": \"ⱥɐɑ\",\n  \"aa\": \"ꜳ\",\n  \"ae\": \"æǽǣ\",\n  \"ao\": \"ꜵ\",\n  \"au\": \"ꜷ\",\n  \"av\": \"ꜹꜻ\",\n  \"ay\": \"ꜽ\",\n  \"b\": \"ƀɓƃ\",\n  \"c\": \"ꜿƈȼↄ\",\n  \"d\": \"đɗɖᴅƌꮷԁɦ\",\n  \"e\": \"ɛǝᴇɇ\",\n  \"f\": \"ꝼƒ\",\n  \"g\": \"ǥɠꞡᵹꝿɢ\",\n  \"h\": \"ħⱨⱶɥ\",\n  \"i\": \"ɨı\",\n  \"j\": \"ɉȷ\",\n  \"k\": \"ƙⱪꝁꝃꝅꞣ\",\n  \"l\": \"łƚɫⱡꝉꝇꞁɭ\",\n  \"m\": \"ɱɯϻ\",\n  \"n\": \"ꞥƞɲꞑᴎлԉ\",\n  \"o\": \"øǿɔɵꝋꝍᴑ\",\n  \"oe\": \"œ\",\n  \"oi\": \"ƣ\",\n  \"oo\": \"ꝏ\",\n  \"ou\": \"ȣ\",\n  \"p\": \"ƥᵽꝑꝓꝕρ\",\n  \"q\": \"ꝗꝙɋ\",\n  \"r\": \"ɍɽꝛꞧꞃ\",\n  \"s\": \"ßȿꞩꞅʂ\",\n  \"t\": \"ŧƭʈⱦꞇ\",\n  \"th\": \"þ\",\n  \"tz\": \"ꜩ\",\n  \"u\": \"ʉ\",\n  \"v\": \"ʋꝟʌ\",\n  \"vy\": \"ꝡ\",\n  \"w\": \"ⱳ\",\n  \"y\": \"ƴɏỿ\",\n  \"z\": \"ƶȥɀⱬꝣ\",\n  \"hv\": \"ƕ\"\n};\n\nfor (let latin in latin_condensed) {\n  let unicode = latin_condensed[latin] || '';\n\n  for (let i = 0; i < unicode.length; i++) {\n    let char = unicode.substring(i, i + 1);\n    latin_convert[char] = latin;\n  }\n}\n\nconst convert_pat = new RegExp(Object.keys(latin_convert).join('|') + '|' + accent_pat, 'gu');\n/**\n * Initialize the unicode_map from the give code point ranges\n *\n * @param {TCodePoints=} _code_points\n */\n\nconst initialize = _code_points => {\n  if (unicode_map !== undefined) return;\n  unicode_map = generateMap(_code_points || code_points);\n};\n/**\n * Helper method for normalize a string\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\n * @param {string} str\n * @param {string} form\n */\n\nconst normalize = (str, form = 'NFKD') => str.normalize(form);\n/**\n * Remove accents without reordering string\n * calling str.normalize('NFKD') on \\u{594}\\u{595}\\u{596} becomes \\u{596}\\u{594}\\u{595}\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n * @param {string} str\n * @return {string}\n */\n\nconst asciifold = str => {\n  return toArray(str).reduce(\n  /**\n   * @param {string} result\n   * @param {string} char\n   */\n  (result, char) => {\n    return result + _asciifold(char);\n  }, '');\n};\n/**\n * @param {string} str\n * @return {string}\n */\n\nconst _asciifold = str => {\n  str = normalize(str).toLowerCase().replace(convert_pat, (\n  /** @type {string} */\n  char) => {\n    return latin_convert[char] || '';\n  }); //return str;\n\n  return normalize(str, 'NFC');\n};\n/**\n * Generate a list of unicode variants from the list of code points\n * @param {TCodePoints} code_points\n * @yield {TCodePointObj}\n */\n\nfunction* generator(code_points) {\n  for (const [code_point_min, code_point_max] of code_points) {\n    for (let i = code_point_min; i <= code_point_max; i++) {\n      let composed = String.fromCharCode(i);\n      let folded = asciifold(composed);\n\n      if (folded == composed.toLowerCase()) {\n        continue;\n      } // skip when folded is a string longer than 3 characters long\n      // bc the resulting regex patterns will be long\n      // eg:\n      // folded صلى الله عليه وسلم length 18 code point 65018\n      // folded جل جلاله length 8 code point 65019\n\n\n      if (folded.length > max_char_length) {\n        continue;\n      }\n\n      if (folded.length == 0) {\n        continue;\n      }\n\n      yield {\n        folded: folded,\n        composed: composed,\n        code_point: i\n      };\n    }\n  }\n}\n/**\n * Generate a unicode map from the list of code points\n * @param {TCodePoints} code_points\n * @return {TUnicodeSets}\n */\n\nconst generateSets = code_points => {\n  /** @type {{[key:string]:Set<string>}} */\n  const unicode_sets = {};\n  /**\n   * @param {string} folded\n   * @param {string} to_add\n   */\n\n  const addMatching = (folded, to_add) => {\n    /** @type {Set<string>} */\n    const folded_set = unicode_sets[folded] || new Set();\n    const patt = new RegExp('^' + setToPattern(folded_set) + '$', 'iu');\n\n    if (to_add.match(patt)) {\n      return;\n    }\n\n    folded_set.add(escape_regex(to_add));\n    unicode_sets[folded] = folded_set;\n  };\n\n  for (let value of generator(code_points)) {\n    addMatching(value.folded, value.folded);\n    addMatching(value.folded, value.composed);\n  }\n\n  return unicode_sets;\n};\n/**\n * Generate a unicode map from the list of code points\n * ae => (?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))\n *\n * @param {TCodePoints} code_points\n * @return {TUnicodeMap}\n */\n\nconst generateMap = code_points => {\n  /** @type {TUnicodeSets} */\n  const unicode_sets = generateSets(code_points);\n  /** @type {TUnicodeMap} */\n\n  const unicode_map = {};\n  /** @type {string[]} */\n\n  let multi_char = [];\n\n  for (let folded in unicode_sets) {\n    let set = unicode_sets[folded];\n\n    if (set) {\n      unicode_map[folded] = setToPattern(set);\n    }\n\n    if (folded.length > 1) {\n      multi_char.push(escape_regex(folded));\n    }\n  }\n\n  multi_char.sort((a, b) => b.length - a.length);\n  const multi_char_patt = arrayToPattern(multi_char);\n  multi_char_reg = new RegExp('^' + multi_char_patt, 'u');\n  return unicode_map;\n};\n/**\n * Map each element of an array from it's folded value to all possible unicode matches\n * @param {string[]} strings\n * @param {number} min_replacement\n * @return {string}\n */\n\nconst mapSequence = (strings, min_replacement = 1) => {\n  let chars_replaced = 0;\n  strings = strings.map(str => {\n    if (unicode_map[str]) {\n      chars_replaced += str.length;\n    }\n\n    return unicode_map[str] || str;\n  });\n\n  if (chars_replaced >= min_replacement) {\n    return sequencePattern(strings);\n  }\n\n  return '';\n};\n/**\n * Convert a short string and split it into all possible patterns\n * Keep a pattern only if min_replacement is met\n *\n * 'abc'\n * \t\t=> [['abc'],['ab','c'],['a','bc'],['a','b','c']]\n *\t\t=> ['abc-pattern','ab-c-pattern'...]\n *\n *\n * @param {string} str\n * @param {number} min_replacement\n * @return {string}\n */\n\nconst substringsToPattern = (str, min_replacement = 1) => {\n  min_replacement = Math.max(min_replacement, str.length - 1);\n  return arrayToPattern(allSubstrings(str).map(sub_pat => {\n    return mapSequence(sub_pat, min_replacement);\n  }));\n};\n/**\n * Convert an array of sequences into a pattern\n * [{start:0,end:3,length:3,substr:'iii'}...] => (?:iii...)\n *\n * @param {Sequence[]} sequences\n * @param {boolean} all\n */\n\nconst sequencesToPattern = (sequences, all = true) => {\n  let min_replacement = sequences.length > 1 ? 1 : 0;\n  return arrayToPattern(sequences.map(sequence => {\n    let seq = [];\n    const len = all ? sequence.length() : sequence.length() - 1;\n\n    for (let j = 0; j < len; j++) {\n      seq.push(substringsToPattern(sequence.substrs[j] || '', min_replacement));\n    }\n\n    return sequencePattern(seq);\n  }));\n};\n/**\n * Return true if the sequence is already in the sequences\n * @param {Sequence} needle_seq\n * @param {Sequence[]} sequences\n */\n\n\nconst inSequences = (needle_seq, sequences) => {\n  for (const seq of sequences) {\n    if (seq.start != needle_seq.start || seq.end != needle_seq.end) {\n      continue;\n    }\n\n    if (seq.substrs.join('') !== needle_seq.substrs.join('')) {\n      continue;\n    }\n\n    let needle_parts = needle_seq.parts;\n    /**\n     * @param {TSequencePart} part\n     */\n\n    const filter = part => {\n      for (const needle_part of needle_parts) {\n        if (needle_part.start === part.start && needle_part.substr === part.substr) {\n          return false;\n        }\n\n        if (part.length == 1 || needle_part.length == 1) {\n          continue;\n        } // check for overlapping parts\n        // a = ['::=','==']\n        // b = ['::','===']\n        // a = ['r','sm']\n        // b = ['rs','m']\n\n\n        if (part.start < needle_part.start && part.end > needle_part.start) {\n          return true;\n        }\n\n        if (needle_part.start < part.start && needle_part.end > part.start) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    let filtered = seq.parts.filter(filter);\n\n    if (filtered.length > 0) {\n      continue;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nclass Sequence {\n  constructor() {\n    /** @type {TSequencePart[]} */\n    this.parts = [];\n    /** @type {string[]} */\n\n    this.substrs = [];\n    this.start = 0;\n    this.end = 0;\n  }\n  /**\n   * @param {TSequencePart|undefined} part\n   */\n\n\n  add(part) {\n    if (part) {\n      this.parts.push(part);\n      this.substrs.push(part.substr);\n      this.start = Math.min(part.start, this.start);\n      this.end = Math.max(part.end, this.end);\n    }\n  }\n\n  last() {\n    return this.parts[this.parts.length - 1];\n  }\n\n  length() {\n    return this.parts.length;\n  }\n  /**\n   * @param {number} position\n   * @param {TSequencePart} last_piece\n   */\n\n\n  clone(position, last_piece) {\n    let clone = new Sequence();\n    let parts = JSON.parse(JSON.stringify(this.parts));\n    let last_part = parts.pop();\n\n    for (const part of parts) {\n      clone.add(part);\n    }\n\n    let last_substr = last_piece.substr.substring(0, position - last_part.start);\n    let clone_last_len = last_substr.length;\n    clone.add({\n      start: last_part.start,\n      end: last_part.start + clone_last_len,\n      length: clone_last_len,\n      substr: last_substr\n    });\n    return clone;\n  }\n\n}\n/**\n * Expand a regular expression pattern to include unicode variants\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n * Issue:\n *  ﺊﺋ [ 'ﺊ = \\\\u{fe8a}', 'ﺋ = \\\\u{fe8b}' ]\n *\tbecomes:\tئئ [ 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}', 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}' ]\n *\n *\tİĲ = IIJ = ⅡJ\n *\n * \t1/2/4\n *\n * @param {string} str\n * @return {string|undefined}\n */\n\n\nconst getPattern = str => {\n  initialize();\n  str = asciifold(str);\n  let pattern = '';\n  let sequences = [new Sequence()];\n\n  for (let i = 0; i < str.length; i++) {\n    let substr = str.substring(i);\n    let match = substr.match(multi_char_reg);\n    const char = str.substring(i, i + 1);\n    const match_str = match ? match[0] : null; // loop through sequences\n    // add either the char or multi_match\n\n    let overlapping = [];\n    let added_types = new Set();\n\n    for (const sequence of sequences) {\n      const last_piece = sequence.last();\n\n      if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {\n        // if we have a multi match\n        if (match_str) {\n          const len = match_str.length;\n          sequence.add({\n            start: i,\n            end: i + len,\n            length: len,\n            substr: match_str\n          });\n          added_types.add('1');\n        } else {\n          sequence.add({\n            start: i,\n            end: i + 1,\n            length: 1,\n            substr: char\n          });\n          added_types.add('2');\n        }\n      } else if (match_str) {\n        let clone = sequence.clone(i, last_piece);\n        const len = match_str.length;\n        clone.add({\n          start: i,\n          end: i + len,\n          length: len,\n          substr: match_str\n        });\n        overlapping.push(clone);\n      } else {\n        // don't add char\n        // adding would create invalid patterns: 234 => [2,34,4]\n        added_types.add('3');\n      }\n    } // if we have overlapping\n\n\n    if (overlapping.length > 0) {\n      // ['ii','iii'] before ['i','i','iii']\n      overlapping = overlapping.sort((a, b) => {\n        return a.length() - b.length();\n      });\n\n      for (let clone of overlapping) {\n        // don't add if we already have an equivalent sequence\n        if (inSequences(clone, sequences)) {\n          continue;\n        }\n\n        sequences.push(clone);\n      }\n\n      continue;\n    } // if we haven't done anything unique\n    // clean up the patterns\n    // helps keep patterns smaller\n    // if str = 'r₨㎧aarss', pattern will be 446 instead of 655\n\n\n    if (i > 0 && added_types.size == 1 && !added_types.has('3')) {\n      pattern += sequencesToPattern(sequences, false);\n      let new_seq = new Sequence();\n      const old_seq = sequences[0];\n\n      if (old_seq) {\n        new_seq.add(old_seq.last());\n      }\n\n      sequences = [new_seq];\n    }\n  }\n\n  pattern += sequencesToPattern(sequences, true);\n  return pattern;\n};\n\nexport { _asciifold, asciifold, code_points, generateMap, generateSets, generator, getPattern, initialize, mapSequence, normalize, substringsToPattern, unicode_map };\n//# sourceMappingURL=index.js.map\n","\nimport { asciifold } from '@orchidjs/unicode-variants';\nimport * as T from './types';\n\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttr = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    return obj[name];\n};\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttrNesting = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    var part, names = name.split(\".\");\n\twhile( (part = names.shift()) && (obj = obj[part]));\n    return obj;\n};\n\n/**\n * Calculates how close of a match the\n * given value is against a search token.\n *\n */\nexport const scoreValue = (value:string, token:T.Token, weight:number ):number => {\n\tvar score, pos;\n\n\tif (!value) return 0;\n\n\tvalue = value + '';\n\tif( token.regex == null ) return 0;\n\tpos = value.search(token.regex);\n\tif (pos === -1) return 0;\n\n\tscore = token.string.length / value.length;\n\tif (pos === 0) score += 0.5;\n\n\treturn score * weight;\n};\n\n\n/**\n * Cast object property to an array if it exists and has a value\n *\n */\nexport const propToArray = (obj:{[key:string]:any}, key:string) => {\n\tvar value = obj[key];\n\n\tif( typeof value == 'function' ) return value;\n\n\tif( value && !Array.isArray(value) ){\n\t\tobj[key] = [value];\n\t}\n}\n\n\n/**\n * Iterates over arrays and hashes.\n *\n * ```\n * iterate(this.items, function(item, id) {\n *    // invoked for each item\n * });\n * ```\n *\n */\nexport const iterate = (object:[]|{[key:string]:any}, callback:(value:any,key:any)=>any) => {\n\n\tif ( Array.isArray(object)) {\n\t\tobject.forEach(callback);\n\n\t}else{\n\n\t\tfor (var key in object) {\n\t\t\tif (object.hasOwnProperty(key)) {\n\t\t\t\tcallback(object[key], key);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nexport const cmp = (a:number|string, b:number|string) => {\n\tif (typeof a === 'number' && typeof b === 'number') {\n\t\treturn a > b ? 1 : (a < b ? -1 : 0);\n\t}\n\ta = asciifold(a + '').toLowerCase();\n\tb = asciifold(b + '').toLowerCase();\n\tif (a > b) return 1;\n\tif (b > a) return -1;\n\treturn 0;\n};\n","/**\n * sifter.js\n * Copyright (c) 2013–2020 Brian Reavis & contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n * @author Brian Reavis <brian@thirdroute.com>\n */\n\nimport { scoreValue, getAttr, getAttrNesting, propToArray, iterate, cmp } from './utils';\nimport { getPattern, escape_regex } from '@orchidjs/unicode-variants';\nimport * as T from './types';\n\nclass Sifter{\n\n\tpublic items: any; // []|{};\n\tpublic settings: T.Settings;\n\n\t/**\n\t * Textually searches arrays and hashes of objects\n\t * by property (or multiple properties). Designed\n\t * specifically for autocomplete.\n\t *\n\t */\n\tconstructor(items:any, settings:T.Settings) {\n\t\tthis.items = items;\n\t\tthis.settings = settings || {diacritics: true};\n\t};\n\n\t/**\n\t * Splits a search string into an array of individual\n\t * regexps to be used to match results.\n\t *\n\t */\n\ttokenize(query:string, respect_word_boundaries?:boolean, weights?:T.Weights ):T.Token[] {\n\t\tif (!query || !query.length) return [];\n\n\t\tconst tokens:T.Token[]\t= [];\n\t\tconst words\t\t\t\t= query.split(/\\s+/);\n\t\tvar field_regex:RegExp;\n\n\t\tif( weights ){\n\t\t\tfield_regex = new RegExp( '^('+ Object.keys(weights).map(escape_regex).join('|')+')\\:(.*)$');\n\t\t}\n\n\t\twords.forEach((word:string) => {\n\t\t\tlet field_match;\n\t\t\tlet field:null|string\t= null;\n\t\t\tlet regex:null|string\t= null;\n\n\t\t\t// look for \"field:query\" tokens\n\t\t\tif( field_regex && (field_match = word.match(field_regex)) ){\n\t\t\t\tfield\t= field_match[1]!;\n\t\t\t\tword\t= field_match[2]!;\n\t\t\t}\n\n\t\t\tif( word.length > 0 ){\n\t\t\t\tif( this.settings.diacritics ){\n\t\t\t\t\tregex = getPattern(word) || null;\n\t\t\t\t}else{\n\t\t\t\t\tregex = escape_regex(word);\n\t\t\t\t}\n\t\t\t\tif( regex && respect_word_boundaries ) regex = \"\\\\b\"+regex;\n\t\t\t}\n\n\t\t\ttokens.push({\n\t\t\t\tstring : word,\n\t\t\t\tregex  : regex ? new RegExp(regex,'iu') : null,\n\t\t\t\tfield  : field,\n\t\t\t});\n\t\t});\n\n\t\treturn tokens;\n\t};\n\n\n\t/**\n\t * Returns a function to be used to score individual results.\n\t *\n\t * Good matches will have a higher score than poor matches.\n\t * If an item is not a match, 0 will be returned by the function.\n\t *\n\t * @returns {T.ScoreFn}\n\t */\n\tgetScoreFunction(query:string, options:T.UserOptions ){\n\t\tvar search = this.prepareSearch(query, options);\n\t\treturn this._getScoreFunction(search);\n\t}\n\n\t/**\n\t * @returns {T.ScoreFn}\n\t *\n\t */\n\t_getScoreFunction(search:T.PrepareObj ){\n\t\tconst tokens\t\t= search.tokens,\n\t\ttoken_count\t\t\t= tokens.length;\n\n\t\tif (!token_count) {\n\t\t\treturn function() { return 0; };\n\t\t}\n\n\t\tconst fields\t= search.options.fields,\n\t\tweights\t\t\t= search.weights,\n\t\tfield_count\t\t= fields.length,\n\t\tgetAttrFn\t\t= search.getAttrFn;\n\n\t\tif (!field_count) {\n\t\t\treturn function() { return 1; };\n\t\t}\n\n\n\t\t/**\n\t\t * Calculates the score of an object\n\t\t * against the search query.\n\t\t *\n\t\t */\n\t\tconst scoreObject = (function() {\n\n\n\t\t\tif (field_count === 1) {\n\t\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\t\tconst field = fields[0]!.field;\n\t\t\t\t\treturn scoreValue(getAttrFn(data, field), token, weights[field]||1);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\tvar sum = 0;\n\n\t\t\t\t// is the token specific to a field?\n\t\t\t\tif( token.field ){\n\n\t\t\t\t\tconst value = getAttrFn(data, token.field);\n\n\t\t\t\t\tif( !token.regex && value ){\n\t\t\t\t\t\tsum += (1/field_count);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += scoreValue(value, token, 1);\n\t\t\t\t\t}\n\n\n\n\t\t\t\t}else{\n\t\t\t\t\titerate(weights, (weight:number, field:string) => {\n\t\t\t\t\t\tsum += scoreValue(getAttrFn(data, field), token, weight);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn sum / field_count;\n\t\t\t};\n\t\t})();\n\n\t\tif (token_count === 1) {\n\t\t\treturn function(data:{}) {\n\t\t\t\treturn scoreObject(tokens[0]!, data);\n\t\t\t};\n\t\t}\n\n\t\tif (search.options.conjunction === 'and') {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar score, sum = 0;\n\t\t\t\tfor( let token of tokens){\n\t\t\t\t\tscore = scoreObject(token, data);\n\t\t\t\t\tif (score <= 0) return 0;\n\t\t\t\t\tsum += score;\n\t\t\t\t}\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar sum = 0;\n\t\t\t\titerate(tokens,(token:T.Token)=>{\n\t\t\t\t\tsum += scoreObject(token, data);\n\t\t\t\t});\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Returns a function that can be used to compare two\n\t * results, for sorting purposes. If no sorting should\n\t * be performed, `null` will be returned.\n\t *\n\t * @return function(a,b)\n\t */\n\tgetSortFunction(query:string, options:T.UserOptions) {\n\t\tvar search  = this.prepareSearch(query, options);\n\t\treturn this._getSortFunction(search);\n\t}\n\n\t_getSortFunction(search:T.PrepareObj){\n\t\tvar implicit_score,\n\t\tsort_flds:T.Sort[]\t= [];\n\n\t\tconst self\t= this,\n\t\toptions\t\t= search.options,\n\t\tsort\t\t= (!search.query && options.sort_empty) ? options.sort_empty : options.sort;\n\n\n\t\tif( typeof sort == 'function' ){\n\t\t\treturn sort.bind(this);\n\t\t}\n\n\t\t/**\n\t\t * Fetches the specified sort field value\n\t\t * from a search result item.\n\t\t *\n\t\t */\n\t\tconst get_field = function(name:string, result:T.ResultItem):string|number {\n\t\t\tif (name === '$score') return result.score;\n\t\t\treturn search.getAttrFn(self.items[result.id], name);\n\t\t};\n\n\t\t// parse options\n\t\tif (sort) {\n\t\t\tfor( let s of sort ){\n\t\t\t\tif (search.query || s.field !== '$score') {\n\t\t\t\t\tsort_flds.push(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// the \"$score\" field is implied to be the primary\n\t\t// sort field, unless it's manually specified\n\t\tif (search.query) {\n\t\t\timplicit_score = true;\n\t\t\tfor( let fld of sort_flds ){\n\t\t\t\tif( fld.field === '$score' ){\n\t\t\t\t\timplicit_score = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (implicit_score) {\n\t\t\t\tsort_flds.unshift({field: '$score', direction: 'desc'});\n\t\t\t}\n\n\t\t// without a search.query, all items will have the same score\n\t\t} else {\n\t\t\tsort_flds = sort_flds.filter((fld) => fld.field !== '$score' );\n\t\t}\n\n\n\t\t// build function\n\t\tconst sort_flds_count = sort_flds.length;\n\t\tif (!sort_flds_count) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn function(a:T.ResultItem, b:T.ResultItem) {\n\t\t\tvar result, field;\n\t\t\tfor( let sort_fld of sort_flds ){\n\t\t\t\tfield = sort_fld.field;\n\n\t\t\t\tlet\tmultiplier = sort_fld.direction === 'desc' ? -1 : 1;\n\n\t\t\t\tresult = multiplier * cmp(\n\t\t\t\t\tget_field(field, a),\n\t\t\t\t\tget_field(field, b)\n\t\t\t\t);\n\t\t\t\tif (result) return result;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\n\t};\n\n\t/**\n\t * Parses a search query and returns an object\n\t * with tokens and fields ready to be populated\n\t * with results.\n\t *\n\t */\n\tprepareSearch(query:string, optsUser:T.UserOptions):T.PrepareObj {\n\t\tconst weights:T.Weights = {};\n\t\tvar options\t\t= Object.assign({},optsUser) as T.Options;\n\n\t\tpropToArray(options,'sort');\n\t\tpropToArray(options,'sort_empty');\n\n\t\t// convert fields to new format\n\t\tif( options.fields ){\n\t\t\tpropToArray(options,'fields');\n\t\t\tconst fields:T.Field[] = [];\n\t\t\toptions.fields.forEach((field:string|T.Field) => {\n\t\t\t\tif( typeof field == 'string' ){\n\t\t\t\t\tfield = {field:field,weight:1};\n\t\t\t\t}\n\t\t\t\tfields.push(field);\n\t\t\t\tweights[field.field] = ('weight' in field) ? field.weight : 1;\n\t\t\t});\n\t\t\toptions.fields = fields;\n\t\t}\n\n\n\t\treturn {\n\t\t\toptions\t\t: options as T.Options,\n\t\t\tquery\t\t: query.toLowerCase().trim(),\n\t\t\ttokens\t\t: this.tokenize(query, options.respect_word_boundaries, weights),\n\t\t\ttotal\t\t: 0,\n\t\t\titems\t\t: [],\n\t\t\tweights\t\t: weights,\n\t\t\tgetAttrFn\t: (options.nesting) ? getAttrNesting : getAttr,\n\t\t};\n\t};\n\n\t/**\n\t * Searches through all items and returns a sorted array of matches.\n\t *\n\t */\n\tsearch(query:string, options:T.UserOptions) : T.PrepareObj {\n\t\tvar self = this, score, search: T.PrepareObj;\n\n\t\tsearch  = this.prepareSearch(query, options);\n\t\toptions = search.options;\n\t\tquery   = search.query;\n\n\t\t// generate result scoring function\n\t\tconst fn_score:T.ScoreFn = options.score || self._getScoreFunction(search);\n\n\t\t// perform search and sort\n\t\tif (query.length) {\n\t\t\titerate(self.items, (item:T.ResultItem, id:string|number) => {\n\t\t\t\tscore = fn_score(item);\n\t\t\t\tif (options.filter === false || score > 0) {\n\t\t\t\t\tsearch.items.push({'score': score, 'id': id});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\titerate(self.items, (_:T.ResultItem, id:string|number) => {\n\t\t\t\tsearch.items.push({'score': 1, 'id': id});\n\t\t\t});\n\t\t}\n\n\t\tconst fn_sort = self._getSortFunction(search);\n\t\tif (fn_sort) search.items.sort(fn_sort);\n\n\t\t// apply limits\n\t\tsearch.total = search.items.length;\n\t\tif (typeof options.limit === 'number') {\n\t\t\tsearch.items = search.items.slice(0, options.limit);\n\t\t}\n\n\t\treturn search;\n\t};\n}\n\nexport { Sifter, scoreValue, getAttr, getAttrNesting, propToArray, iterate, cmp, getPattern }\n"],"names":["arrayToPattern","chars","maxValueLength","sequencePattern","array","hasDuplicates","pattern","prev_char_count","prev_pattern","char","i","setToPattern","toArray","escape_regex","str","Math","unicodeLength","p","Array","allSubstrings","input","result","start","suba","tmp","subresult","code_points","accent_pat","max_char_length","latin_convert","latin_condensed","unicode","convert_pat","Object","initialize","_code_points","unicode_map","generateMap","normalize","form","asciifold","_asciifold","composed","String","folded","code_point","generateSets","unicode_sets","addMatching","folded_set","patt","to_add","generator","value","multi_char","set","b","a","multi_char_patt","multi_char_reg","mapSequence","min_replacement","chars_replaced","strings","substringsToPattern","sub_pat","sequencesToPattern","all","sequences","sequence","seq","len","j","inSequences","needle_seq","needle_parts","filter","part","needle_part","filtered","constructor","add","last","length","clone","parts","JSON","last_part","last_substr","last_piece","position","clone_last_len","end","substr","getPattern","match","match_str","overlapping","added_types","new_seq","old_seq","getAttr","obj","name","getAttrNesting","names","split","shift","scoreValue","token","weight","score","pos","regex","search","string","propToArray","key","isArray","iterate","object","callback","forEach","hasOwnProperty","cmp","toLowerCase","Sifter","items","settings","diacritics","tokenize","query","respect_word_boundaries","weights","tokens","words","field_regex","RegExp","keys","map","join","word","field_match","field","push","getScoreFunction","options","prepareSearch","_getScoreFunction","token_count","fields","field_count","getAttrFn","scoreObject","data","sum","conjunction","getSortFunction","_getSortFunction","implicit_score","sort_flds","self","sort","sort_empty","bind","get_field","id","s","fld","unshift","direction","sort_flds_count","sort_fld","multiplier","optsUser","assign","trim","total","nesting","fn_score","item","_","fn_sort","limit","slice"],"mappings":";;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACaA,MAAAA,cAAc,GAAIC,KAAD,IAAU;AAEvCA,EAAAA,KAAK,GAAGA,KAAK,CAALA,MAAAA,CAARA,OAAQA,CAARA;;AAEA,MAAIA,KAAK,CAALA,MAAAA,GAAJ,CAAA,EAAsB;AACrB,WAAOA,KAAK,CAALA,CAAK,CAALA,IAAP,EAAA;AACA;;AAED,SAAQC,cAAc,CAAdA,KAAc,CAAdA,IAAD,CAACA,GAA8B,MAAID,KAAK,CAALA,IAAAA,CAAJ,EAAIA,CAAJ,GAA/B,GAACC,GAAuD,QAAMD,KAAK,CAALA,IAAAA,CAAN,GAAMA,CAAN,GAA/D,GAAA;AARM,CAAMD;AAWb;AACA;AACA;AACA;;;AACaG,MAAAA,eAAe,GAAIC,KAAD,IAAS;AAEvC,MAAI,CAACC,aAAa,CAAlB,KAAkB,CAAlB,EAA2B;AAC1B,WAAOD,KAAK,CAALA,IAAAA,CAAP,EAAOA,CAAP;AACA;;AAED,MAAIE,OAAO,GAAX,EAAA;AACA,MAAIC,eAAe,GAAnB,CAAA;;AAEA,QAAMC,YAAY,GAAG,MAAI;AACxB,QAAID,eAAe,GAAnB,CAAA,EAAyB;AACxBD,MAAAA,OAAO,IAAI,MAAA,eAAA,GAAXA,GAAAA;AACA;AAHF,GAAA;;AAMAF,EAAAA,KAAK,CAALA,OAAAA,CAAc,CAAA,IAAA,EAAA,CAAA,KAAU;AAEvB,QAAIK,IAAI,KAAKL,KAAK,CAACM,CAAC,GAApB,CAAkB,CAAlB,EAAyB;AACxBH,MAAAA,eAAe;AACf;AACA;;AAEDC,IAAAA,YAAY;AAEZF,IAAAA,OAAO,IAAPA,IAAAA;AACAC,IAAAA,eAAe,GAAfA,CAAAA;AAVDH,GAAAA;AAaAI,EAAAA,YAAY;AAEZ,SAAA,OAAA;AA9BM,CAAML;AAoCb;AACA;AACA;AACA;AACA;AACA;AACA;;;AACaQ,MAAAA,YAAY,GAAIV,KAAD,IAAS;AACpC,MAAIG,KAAK,GAAGQ,OAAO,CAAnB,KAAmB,CAAnB;AACA,SAAOZ,cAAc,CAArB,KAAqB,CAArB;AAFM,CAAMW;AAOb;AACA;AACA;AACA;AACA;;;AACaN,MAAAA,aAAa,GAAID,KAAD,IAAW;AACpC,SAAQ,IAAA,GAAA,CAAD,KAAC,EAAD,IAAC,KAAyBA,KAAK,CAAtC,MAAA;AADG,CAAMC;AAKb;AACA;AACA;AACA;AACA;;;AACaQ,MAAAA,YAAY,GAAIC,GAAD,IAAS;AACpC,SAAO,CAACA,GAAG,GAAJ,EAAA,EAAA,OAAA,CAAA,4BAAA,EAAP,MAAO,CAAP;AADM,CAAMD;AAIb;AACA;AACA;AACA;AACA;;;AACaX,MAAAA,cAAc,GAAIE,KAAD,IAAW;AACxC,SAAOA,KAAK,CAALA,MAAAA,CAAc,CAAA,OAAA,EAAA,KAAA,KAAoBW,IAAI,CAAJA,GAAAA,CAAAA,OAAAA,EAAiBC,aAAa,CAAhEZ,KAAgE,CAA9BW,CAAlCX,EAAP,CAAOA,CAAP;AADM,CAAMF;AAKb;AACA;AACA;;;AACac,MAAAA,aAAa,GAAIF,GAAD,IAAS;AACrC,SAAOF,OAAO,CAAPA,GAAO,CAAPA,CAAP,MAAA;AADM,CAAMI;AAIb;AACA;AACA;AACA;;;AACO,MAAMJ,OAAO,GAAIK,CAAD,IAAOC,KAAK,CAALA,IAAAA,CAAAA,CAAAA,CAAvB;;;;AC9GP;AACA;AACA;AACA;AACA;AACA;AACaC,MAAAA,aAAa,GAAIC,KAAD,IAAW;AAEpC,MAAIA,KAAK,CAALA,MAAAA,KAAJ,CAAA,EAAwB,OAAO,CAAC,CAAR,KAAQ,CAAD,CAAP;AAE3B;;AACG,MAAIC,MAAM,GAAV,EAAA;AAEH,QAAMC,KAAK,GAAGF,KAAK,CAALA,SAAAA,CAAd,CAAcA,CAAd;AACG,QAAMG,IAAI,GAAGJ,aAAa,CAA1B,KAA0B,CAA1B;AAEHI,EAAAA,IAAI,CAAJA,OAAAA,CAAa,UAAA,SAAA,EAAoB;AAC1B,QAAIC,GAAG,GAAGC,SAAS,CAATA,KAAAA,CAAV,CAAUA,CAAV;AACAD,IAAAA,GAAG,CAAHA,CAAG,CAAHA,GAASJ,KAAK,CAALA,MAAAA,CAAAA,CAAAA,IAAkBI,GAAG,CAA9BA,CAA8B,CAA9BA;AACAH,IAAAA,MAAM,CAANA,IAAAA,CAAAA,GAAAA;AAEAG,IAAAA,GAAG,GAAGC,SAAS,CAATA,KAAAA,CAAND,CAAMC,CAAND;AACAA,IAAAA,GAAG,CAAHA,OAAAA,CAAYJ,KAAK,CAALA,MAAAA,CAAZI,CAAYJ,CAAZI;AACAH,IAAAA,MAAM,CAANA,IAAAA,CAAAA,GAAAA;AAPPE,GAAAA;AAUG,SAAA,MAAA;AACH,CArBYJ;;;ACRb;AACA;AACA;AACA;AACA;AACA;AACA;;AAOA;;AACO,MAAMO,WAAW,GAAG,CAAC,CAAA,CAAA,EAArB,KAAqB,CAAD,CAApB;AAEP,MAAMC,UAAU,GAAhB,qCAAA;AAEA;;IACO;AAEP;;AACA,IAAA,cAAA;AAEA,MAAMC,eAAe,GAArB,CAAA;AAEA;;AACA,MAAMC,aAAa,GAAnB,EAAA;AAEA;;AACA,MAAMC,eAAe,GAAG;AACvB,OADuB,IAAA;AAEvB,OAFuB,GAAA;AAGvB,OAHuB,KAAA;AAIvB,QAJuB,GAAA;AAKvB,QALuB,KAAA;AAMvB,QANuB,GAAA;AAOvB,QAPuB,GAAA;AAQvB,QARuB,IAAA;AASvB,QATuB,GAAA;AAUvB,OAVuB,KAAA;AAWvB,OAXuB,MAAA;AAYvB,OAZuB,UAAA;AAavB,OAbuB,MAAA;AAcvB,OAduB,IAAA;AAevB,OAfuB,QAAA;AAgBvB,OAhBuB,MAAA;AAiBvB,OAjBuB,IAAA;AAkBvB,OAlBuB,IAAA;AAmBvB,OAnBuB,QAAA;AAoBvB,OApBuB,UAAA;AAqBvB,OArBuB,KAAA;AAsBvB,OAtBuB,SAAA;AAuBvB,OAvBuB,SAAA;AAwBvB,QAxBuB,GAAA;AAyBvB,QAzBuB,GAAA;AA0BvB,QA1BuB,GAAA;AA2BvB,QA3BuB,GAAA;AA4BvB,OA5BuB,QAAA;AA6BvB,OA7BuB,KAAA;AA8BvB,OA9BuB,OAAA;AA+BvB,OA/BuB,OAAA;AAgCvB,OAhCuB,OAAA;AAiCvB,QAjCuB,GAAA;AAkCvB,QAlCuB,GAAA;AAmCvB,OAnCuB,GAAA;AAoCvB,OApCuB,KAAA;AAqCvB,QArCuB,GAAA;AAsCvB,OAtCuB,GAAA;AAuCvB,OAvCuB,KAAA;AAwCvB,OAxCuB,OAAA;AAyCvB,QAAM;AAzCiB,CAAxB;;AA6CA,KAAK,IAAL,KAAA,IAAA,eAAA,EAAmC;AAClC,MAAIC,OAAO,GAAGD,eAAe,CAAfA,KAAe,CAAfA,IAAd,EAAA;;AACA,OAAK,IAAIpB,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGqB,OAAO,CAA3B,MAAA,EAAoCrB,CAApC,EAAA,EAAwC;AACvC,QAAID,IAAI,GAAGsB,OAAO,CAAPA,SAAAA,CAAAA,CAAAA,EAAoBrB,CAAC,GAAhC,CAAWqB,CAAX;AACAF,IAAAA,aAAa,CAAbA,IAAa,CAAbA,GAAAA,KAAAA;AACA;AACD;;AAGD,MAAMG,WAAW,GAAG,IAAA,MAAA,CAAWC,MAAM,CAANA,IAAAA,CAAAA,aAAAA,EAAAA,IAAAA,CAAAA,GAAAA,IAAAA,GAAAA,GAAX,UAAA,EAApB,IAAoB,CAApB;AAIA;AACA;AACA;AACA;AACA;;AACaC,MAAAA,UAAU,GAAIC,YAAD,IAAkB;AAC3C,MAAIC,WAAW,KAAf,SAAA,EAAgC;AAChCA,EAAAA,WAAW,GAAGC,WAAW,CAACF,YAAY,IAAtCC,WAAyB,CAAzBA;AAFM,CAAMF;AAMb;AACA;AACA;AACA;AACA;AACA;;;AACaI,MAAAA,SAAS,GAAG,CAAA,GAAA,EAAKC,IAAI,GAAT,MAAA,KAAqBzB,GAAG,CAAHA,SAAAA,CAAvC,IAAuCA,CAAjCwB;AAIb;AACA;AACA;AACA;AACA;AACA;AACA;;;AACaE,MAAAA,SAAS,GAAI1B,GAAD,IAAS;AAEjC,SAAO,OAAO,CAAP,GAAO,CAAP,CAAA,MAAA;AACN;AACF;AACA;AACA;AACE,GAAA,MAAA,EAAA,IAAA,KAAiB;AAChB,WAAOO,MAAM,GAAGoB,UAAU,CAA1B,IAA0B,CAA1B;AANK,GAAA,EAAP,EAAO,CAAP;AAFM,CAAMD;AAcb;AACA;AACA;AACA;;;AACaC,MAAAA,UAAU,GAAI3B,GAAD,IAAS;AAClCA,EAAAA,GAAG,GAAG,SAAS,CAAT,GAAS,CAAT,CAAA,WAAA,GAAA,OAAA,CAAA,WAAA;AAEiB;AAAD,EAAA,IAAA,IAAgC;AACpD,WAAOe,aAAa,CAAbA,IAAa,CAAbA,IAAP,EAAA;AAJgC,GAC5B,CAANf,CADkC;;AAQlC,SAAOwB,SAAS,CAAA,GAAA,EAAhB,KAAgB,CAAhB;AARM,CAAMG;AAgBb;AACA;AACA;AACA;AACA;;;AACO,UAAA,SAAA,CAAA,WAAA,EAAgC;AAEtC,OAAI,MAAM,CAAA,cAAA,EAAV,cAAU,CAAV,IAAA,WAAA,EAA0D;AACzD,SAAI,IAAI/B,CAAC,GAAT,cAAA,EAA4BA,CAAC,IAA7B,cAAA,EAAiDA,CAAjD,EAAA,EAAqD;AAEpD,UAAIgC,QAAQ,GAAIC,MAAM,CAANA,YAAAA,CAAhB,CAAgBA,CAAhB;AACA,UAAIC,MAAM,GAAKJ,SAAS,CAAxB,QAAwB,CAAxB;;AAGA,UAAII,MAAM,IAAIF,QAAQ,CAAtB,WAAcA,EAAd,EAAsC;AACrC;AAPmD,OAAA;AAWpD;AACA;AACA;AACA;;;AACA,UAAIE,MAAM,CAANA,MAAAA,GAAJ,eAAA,EAAqC;AACpC;AACA;;AAED,UAAIA,MAAM,CAANA,MAAAA,IAAJ,CAAA,EAAwB;AACvB;AACA;;AAGD,YAAM;AAACA,QAAAA,MAAM,EAAP,MAAA;AAAeF,QAAAA,QAAQ,EAAvB,QAAA;AAAiCG,QAAAA,UAAU,EAACnC;AAA5C,OAAN;AACA;AACD;AACD;AAGD;AACA;AACA;AACA;AACA;;;AACaoC,MAAAA,YAAY,GAAIpB,WAAD,IAAiB;AAE5C;AACA,QAAMqB,YAAY,GAAlB,EAAA;AAGA;AACD;AACA;AACA;;AACC,QAAMC,WAAW,GAAG,CAAA,MAAA,EAAA,MAAA,KAAmB;AAEtC;AACA,UAAMC,UAAU,GAAGF,YAAY,CAAZA,MAAY,CAAZA,IAAwB,IAA3C,GAA2C,EAA3C;AAEA,UAAMG,IAAI,GAAG,IAAA,MAAA,CAAY,MAAIvC,YAAY,CAAhB,UAAgB,CAAhB,GAAZ,GAAA,EAAb,IAAa,CAAb;;AACA,QAAIwC,MAAM,CAANA,KAAAA,CAAJ,IAAIA,CAAJ,EAAwB;AACvB;AACA;;AAEDF,IAAAA,UAAU,CAAVA,GAAAA,CAAepC,YAAY,CAA3BoC,MAA2B,CAA3BA;AACAF,IAAAA,YAAY,CAAZA,MAAY,CAAZA,GAAAA,UAAAA;AAXD,GAAA;;AAeA,OAAK,IAAL,KAAA,IAAkBK,SAAS,CAA3B,WAA2B,CAA3B,EAA0C;AACzCJ,IAAAA,WAAW,CAACK,KAAK,CAAN,MAAA,EAAcA,KAAK,CAA9BL,MAAW,CAAXA;AACAA,IAAAA,WAAW,CAACK,KAAK,CAAN,MAAA,EAAcA,KAAK,CAA9BL,QAAW,CAAXA;AACA;;AAED,SAAA,YAAA;AA9BM,CAAMF;AAiCb;AACA;AACA;AACA;AACA;AACA;AACA;;;AACaT,MAAAA,WAAW,GAAIX,WAAD,IAAiB;AAE3C;AACA,QAAMqB,YAAY,GAAGD,YAAY,CAAjC,WAAiC,CAAjC;AAEA;;AACA,QAAMV,WAAW,GAAjB,EAAA;AAEA;;AACA,MAAIkB,UAAU,GAAd,EAAA;;AAEA,OAAK,IAAL,MAAA,IAAA,YAAA,EAAiC;AAEhC,QAAIC,GAAG,GAAGR,YAAY,CAAtB,MAAsB,CAAtB;;AACA,QAAA,GAAA,EAAS;AACRX,MAAAA,WAAW,CAAXA,MAAW,CAAXA,GAAsBzB,YAAY,CAAlCyB,GAAkC,CAAlCA;AACA;;AAED,QAAIQ,MAAM,CAANA,MAAAA,GAAJ,CAAA,EAAuB;AACtBU,MAAAA,UAAU,CAAVA,IAAAA,CAAgBzC,YAAY,CAA5ByC,MAA4B,CAA5BA;AACA;AACD;;AAEDA,EAAAA,UAAU,CAAVA,IAAAA,CAAgB,CAAA,CAAA,EAAA,CAAA,KAAUE,CAAC,CAADA,MAAAA,GAAWC,CAAC,CAAtCH,MAAAA;AACA,QAAMI,eAAe,GAAG1D,cAAc,CAAtC,UAAsC,CAAtC;AACA2D,EAAAA,cAAc,GAAG,IAAA,MAAA,CAAW,MAAX,eAAA,EAAjBA,GAAiB,CAAjBA;AAEA,SAAA,WAAA;AA3BM,CAAMtB;AA+Bb;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMuB,WAAW,GAAG,CAAA,OAAA,EAASC,eAAe,GAAxB,CAAA,KAA8B;AACxD,MAAIC,cAAc,GAAlB,CAAA;AAGAC,EAAAA,OAAO,GAAG,OAAO,CAAP,GAAA,CAAajD,GAAD,IAAO;AAC5B,QAAIsB,WAAW,CAAf,GAAe,CAAf,EAAsB;AACrB0B,MAAAA,cAAc,IAAIhD,GAAG,CAArBgD,MAAAA;AACA;;AACD,WAAO1B,WAAW,CAAXA,GAAW,CAAXA,IAAP,GAAA;AAJD2B,GAAU,CAAVA;;AAOA,MAAID,cAAc,IAAlB,eAAA,EAAuC;AACtC,WAAO3D,eAAe,CAAtB,OAAsB,CAAtB;AACA;;AAED,SAAA,EAAA;AAfM,CAAA;AAkBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAM6D,mBAAmB,GAAG,CAAA,GAAA,EAAKH,eAAe,GAApB,CAAA,KAA2B;AAE7DA,EAAAA,eAAe,GAAG9C,IAAI,CAAJA,GAAAA,CAAAA,eAAAA,EAAyBD,GAAG,CAAHA,MAAAA,GAA3C+C,CAAkB9C,CAAlB8C;AAEA,SAAO7D,cAAc,CACpB,aAAa,CAAb,GAAa,CAAb,CAAA,GAAA,CAAyBiE,OAAD,IAAY;AACnC,WAAOL,WAAW,CAAA,OAAA,EAAlB,eAAkB,CAAlB;AAFF,GACC,CADoB,CAArB;AAJM,CAAA;AAWP;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMM,kBAAkB,GAAG,CAAA,SAAA,EAAWC,GAAG,GAAd,IAAA,KAAwB;AAElD,MAAIN,eAAe,GAAGO,SAAS,CAATA,MAAAA,GAAAA,CAAAA,GAAAA,CAAAA,GAAtB,CAAA;AACA,SAAOpE,cAAc,CACpB,SAAS,CAAT,GAAA,CAAgBqE,QAAD,IAAa;AAC3B,QAAIC,GAAG,GAAP,EAAA;AACA,UAAMC,GAAG,GAAGJ,GAAG,GAAGE,QAAQ,CAAX,MAAGA,EAAH,GAAuBA,QAAQ,CAARA,MAAAA,KAAtC,CAAA;;AACA,SAAK,IAAIG,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,GAAA,EAAyBA,CAAzB,EAAA,EAA6B;AAC5BF,MAAAA,GAAG,CAAHA,IAAAA,CAASN,mBAAmB,CAACK,QAAQ,CAARA,OAAAA,CAAAA,CAAAA,KAAD,EAAA,EAA5BC,eAA4B,CAA5BA;AACA;;AAED,WAAOnE,eAAe,CAAtB,GAAsB,CAAtB;AARF,GACC,CADoB,CAArB;AAHD,CAAA;AAgBA;AACA;AACA;AACA;AACA;;;AACA,MAAMsE,WAAW,GAAG,CAAA,UAAA,EAAA,SAAA,KAA2B;AAE9C,OAAI,MAAJ,GAAA,IAAA,SAAA,EAA2B;AAE1B,QAAIH,GAAG,CAAHA,KAAAA,IAAaI,UAAU,CAAvBJ,KAAAA,IAAiCA,GAAG,CAAHA,GAAAA,IAAWI,UAAU,CAA1D,GAAA,EAAgE;AAC/D;AACA;;AAED,QAAIJ,GAAG,CAAHA,OAAAA,CAAAA,IAAAA,CAAAA,EAAAA,MAAyBI,UAAU,CAAVA,OAAAA,CAAAA,IAAAA,CAA7B,EAA6BA,CAA7B,EAA0D;AACzD;AACA;;AAGD,QAAIC,YAAY,GAAGD,UAAU,CAA7B,KAAA;AAEA;AACF;AACA;;AACE,UAAME,MAAM,GAAIC,IAAD,IAAS;AAEvB,WAAI,MAAJ,WAAA,IAAA,YAAA,EAAsC;AAErC,YAAIC,WAAW,CAAXA,KAAAA,KAAsBD,IAAI,CAA1BC,KAAAA,IAAoCA,WAAW,CAAXA,MAAAA,KAAuBD,IAAI,CAAnE,MAAA,EAA4E;AAC3E,iBAAA,KAAA;AACA;;AAED,YAAIA,IAAI,CAAJA,MAAAA,IAAAA,CAAAA,IAAoBC,WAAW,CAAXA,MAAAA,IAAxB,CAAA,EAAiD;AAChD;AAPoC,SAAA;AAYrC;AACA;AACA;AACA;;;AACA,YAAID,IAAI,CAAJA,KAAAA,GAAaC,WAAW,CAAxBD,KAAAA,IAAkCA,IAAI,CAAJA,GAAAA,GAAWC,WAAW,CAA5D,KAAA,EAAoE;AACnE,iBAAA,IAAA;AACA;;AAED,YAAIA,WAAW,CAAXA,KAAAA,GAAoBD,IAAI,CAAxBC,KAAAA,IAAkCA,WAAW,CAAXA,GAAAA,GAAkBD,IAAI,CAA5D,KAAA,EAAoE;AACnE,iBAAA,IAAA;AACA;AAED;;AAED,aAAA,KAAA;AA5BD,KAAA;;AA+BA,QAAIE,QAAQ,GAAGT,GAAG,CAAHA,KAAAA,CAAAA,MAAAA,CAAf,MAAeA,CAAf;;AAEA,QAAIS,QAAQ,CAARA,MAAAA,GAAJ,CAAA,EAAyB;AACxB;AACA;;AAED,WAAA,IAAA;AACA;;AAED,SAAA,KAAA;AA1DD,CAAA;;AA6DA,MAAA,QAAA,CAAc;AAEbC,EAAAA,WAAW,GAAE;AAEZ;AACA,SAAA,KAAA,GAAA,EAAA;AAEA;;AACA,SAAA,OAAA,GAAA,EAAA;AACA,SAAA,KAAA,GAAA,CAAA;AACA,SAAA,GAAA,GAAA,CAAA;AACA;AAED;AACD;AACA;;;AACCC,EAAAA,GAAG,CAAA,IAAA,EAAM;AACR,QAAA,IAAA,EAAU;AACT,WAAA,KAAA,CAAA,IAAA,CAAA,IAAA;AACA,WAAA,OAAA,CAAA,IAAA,CAAkBJ,IAAI,CAAtB,MAAA;AACA,WAAA,KAAA,GAAa9D,IAAI,CAAJA,GAAAA,CAAS8D,IAAI,CAAb9D,KAAAA,EAAoB,KAAjC,KAAaA,CAAb;AACA,WAAA,GAAA,GAAWA,IAAI,CAAJA,GAAAA,CAAS8D,IAAI,CAAb9D,GAAAA,EAAkB,KAA7B,GAAWA,CAAX;AACA;AACD;;AAEDmE,EAAAA,IAAI,GAAE;AACL,WAAO,KAAA,KAAA,CAAW,KAAA,KAAA,CAAA,MAAA,GAAlB,CAAO,CAAP;AACA;;AAEDC,EAAAA,MAAM,GAAE;AACP,WAAO,KAAA,KAAA,CAAP,MAAA;AACA;AAED;AACD;AACA;AACA;;;AACCC,EAAAA,KAAK,CAAA,QAAA,EAAA,UAAA,EAAsB;AAC1B,QAAIA,KAAK,GAAG,IAAZ,QAAY,EAAZ;AAEA,QAAIC,KAAK,GAAGC,IAAI,CAAJA,KAAAA,CAAWA,IAAI,CAAJA,SAAAA,CAAe,KAAtC,KAAuBA,CAAXA,CAAZ;AACA,QAAIC,SAAS,GAAGF,KAAK,CAArB,GAAgBA,EAAhB;;AACA,SAAK,MAAL,IAAA,IAAA,KAAA,EAA0B;AACzBD,MAAAA,KAAK,CAALA,GAAAA,CAAAA,IAAAA;AACA;;AAED,QAAII,WAAW,GAAGC,UAAU,CAAVA,MAAAA,CAAAA,SAAAA,CAAAA,CAAAA,EAA8BC,QAAQ,GAACH,SAAS,CAAlE,KAAkBE,CAAlB;AACA,QAAIE,cAAc,GAAGH,WAAW,CAAhC,MAAA;AACAJ,IAAAA,KAAK,CAALA,GAAAA,CAAU;AAAC9D,MAAAA,KAAK,EAACiE,SAAS,CAAhB,KAAA;AAAuBK,MAAAA,GAAG,EAACL,SAAS,CAATA,KAAAA,GAA3B,cAAA;AAA0DJ,MAAAA,MAAM,EAAhE,cAAA;AAAgFU,MAAAA,MAAM,EAACL;AAAvF,KAAVJ;AAEA,WAAA,KAAA;AACA;;AAnDY;AAuDd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;MACaU,UAAU,GAAIhF,GAAD,IAAS;AAClCoB,EAAAA,UAAU;AAEVpB,EAAAA,GAAG,GAAO0B,SAAS,CAAnB1B,GAAmB,CAAnBA;AAEA,MAAIR,OAAO,GAAX,EAAA;AACA,MAAI8D,SAAS,GAAI,CAAC,IAAlB,QAAkB,EAAD,CAAjB;;AAEA,OAAK,IAAI1D,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGI,GAAG,CAAvB,MAAA,EAAgCJ,CAAhC,EAAA,EAAqC;AAEpC,QAAImF,MAAM,GAAG/E,GAAG,CAAHA,SAAAA,CAAb,CAAaA,CAAb;AACA,QAAIiF,KAAK,GAAGF,MAAM,CAANA,KAAAA,CAAZ,cAAYA,CAAZ;AACA,UAAMpF,IAAI,GAAGK,GAAG,CAAHA,SAAAA,CAAAA,CAAAA,EAAgBJ,CAAC,GAA9B,CAAaI,CAAb;AACA,UAAMkF,SAAS,GAAGD,KAAK,GAAGA,KAAK,CAAR,CAAQ,CAAR,GALa,IAKpC,CALoC;AASpC;;AACA,QAAIE,WAAW,GAAf,EAAA;AACA,QAAIC,WAAW,GAAI,IAAnB,GAAmB,EAAnB;;AACA,SAAI,MAAJ,QAAA,IAAA,SAAA,EAAgC;AAE/B,YAAMT,UAAU,GAAGpB,QAAQ,CAA3B,IAAmBA,EAAnB;;AAGA,UAAI,CAAA,UAAA,IAAeoB,UAAU,CAAVA,MAAAA,IAAf,CAAA,IAAyCA,UAAU,CAAVA,GAAAA,IAA7C,CAAA,EAAkE;AAEjE;AACA,YAAA,SAAA,EAAe;AACd,gBAAMlB,GAAG,GAAGyB,SAAS,CAArB,MAAA;AACA3B,UAAAA,QAAQ,CAARA,GAAAA,CAAa;AAAC/C,YAAAA,KAAK,EAAN,CAAA;AAASsE,YAAAA,GAAG,EAAClF,CAAC,GAAd,GAAA;AAAmByE,YAAAA,MAAM,EAAzB,GAAA;AAA8BU,YAAAA,MAAM,EAACG;AAArC,WAAb3B;AACA6B,UAAAA,WAAW,CAAXA,GAAAA,CAAAA,GAAAA;AAHD,SAAA,MAIK;AACJ7B,UAAAA,QAAQ,CAARA,GAAAA,CAAa;AAAC/C,YAAAA,KAAK,EAAN,CAAA;AAASsE,YAAAA,GAAG,EAAClF,CAAC,GAAd,CAAA;AAAiByE,YAAAA,MAAM,EAAvB,CAAA;AAA0BU,YAAAA,MAAM,EAACpF;AAAjC,WAAb4D;AACA6B,UAAAA,WAAW,CAAXA,GAAAA,CAAAA,GAAAA;AACA;AAVF,OAAA,MAYM,IAAA,SAAA,EAAe;AAEpB,YAAId,KAAK,GAAGf,QAAQ,CAARA,KAAAA,CAAAA,CAAAA,EAAZ,UAAYA,CAAZ;AAEA,cAAME,GAAG,GAAGyB,SAAS,CAArB,MAAA;AACAZ,QAAAA,KAAK,CAALA,GAAAA,CAAU;AAAC9D,UAAAA,KAAK,EAAN,CAAA;AAASsE,UAAAA,GAAG,EAAClF,CAAC,GAAd,GAAA;AAAmByE,UAAAA,MAAM,EAAzB,GAAA;AAA8BU,UAAAA,MAAM,EAACG;AAArC,SAAVZ;AAEAa,QAAAA,WAAW,CAAXA,IAAAA,CAAAA,KAAAA;AAPK,OAAA,MASD;AACJ;AACA;AACAC,QAAAA,WAAW,CAAXA,GAAAA,CAAAA,GAAAA;AACA;AA1CkC,KAAA;;;AAgDpC,QAAID,WAAW,CAAXA,MAAAA,GAAJ,CAAA,EAA4B;AAE3B;AACAA,MAAAA,WAAW,GAAG,WAAW,CAAX,IAAA,CAAiB,CAAA,CAAA,EAAA,CAAA,KAAO;AACrC,eAAOxC,CAAC,CAADA,MAAAA,KAAaD,CAAC,CAArB,MAAoBA,EAApB;AADDyC,OAAc,CAAdA;;AAIA,WAAK,IAAL,KAAA,IAAA,WAAA,EAA8B;AAE7B;AACA,YAAIxB,WAAW,CAAA,KAAA,EAAf,SAAe,CAAf,EAAmC;AAClC;AACA;;AAEDL,QAAAA,SAAS,CAATA,IAAAA,CAAAA,KAAAA;AACA;;AAED;AAjEmC,KAAA;AAsEpC;AACA;AACA;;;AACA,QAAI1D,CAAC,GAADA,CAAAA,IAASwF,WAAW,CAAXA,IAAAA,IAATxF,CAAAA,IAAkC,CAACwF,WAAW,CAAXA,GAAAA,CAAvC,GAAuCA,CAAvC,EAA6D;AAC5D5F,MAAAA,OAAO,IAAI4D,kBAAkB,CAAA,SAAA,EAA7B5D,KAA6B,CAA7BA;AACA,UAAI6F,OAAO,GAAG,IAAd,QAAc,EAAd;AACA,YAAMC,OAAO,GAAGhC,SAAS,CAAzB,CAAyB,CAAzB;;AACA,UAAA,OAAA,EAAa;AACZ+B,QAAAA,OAAO,CAAPA,GAAAA,CAAYC,OAAO,CAAnBD,IAAYC,EAAZD;AACA;;AACD/B,MAAAA,SAAS,GAAG,CAAZA,OAAY,CAAZA;AACA;AAED;;AAED9D,EAAAA,OAAO,IAAI4D,kBAAkB,CAAA,SAAA,EAA7B5D,IAA6B,CAA7BA;AAEA,SAAA,OAAA;AACA;;ACnjBD;AACA;AACA;AACA;AACA;AACA;MACa+F,OAAO,GAAG,CAACC,GAAD,EAAyBC,IAAzB,KAA0C;AAC7D,MAAI,CAACD,GAAL,EAAW;AACX,SAAOA,GAAG,CAACC,IAAD,CAAV;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;MACaC,cAAc,GAAG,CAACF,GAAD,EAAyBC,IAAzB,KAA0C;AACpE,MAAI,CAACD,GAAL,EAAW;AACX,MAAIzB,IAAJ;AAAA,MAAU4B,KAAK,GAAGF,IAAI,CAACG,KAAL,CAAW,GAAX,CAAlB;;AACH,SAAO,CAAC7B,IAAI,GAAG4B,KAAK,CAACE,KAAN,EAAR,MAA2BL,GAAG,GAAGA,GAAG,CAACzB,IAAD,CAApC,CAAP,CAAmD;;AAChD,SAAOyB,GAAP;AACH;AAED;AACA;AACA;AACA;AACA;;MACaM,UAAU,GAAG,CAACvD,KAAD,EAAewD,KAAf,EAA8BC,MAA9B,KAAwD;AACjF,MAAIC,KAAJ,EAAWC,GAAX;AAEA,MAAI,CAAC3D,KAAL,EAAY,OAAO,CAAP;AAEZA,EAAAA,KAAK,GAAGA,KAAK,GAAG,EAAhB;AACA,MAAIwD,KAAK,CAACI,KAAN,IAAe,IAAnB,EAA0B,OAAO,CAAP;AAC1BD,EAAAA,GAAG,GAAG3D,KAAK,CAAC6D,MAAN,CAAaL,KAAK,CAACI,KAAnB,CAAN;AACA,MAAID,GAAG,KAAK,CAAC,CAAb,EAAgB,OAAO,CAAP;AAEhBD,EAAAA,KAAK,GAAGF,KAAK,CAACM,MAAN,CAAahC,MAAb,GAAsB9B,KAAK,CAAC8B,MAApC;AACA,MAAI6B,GAAG,KAAK,CAAZ,EAAeD,KAAK,IAAI,GAAT;AAEf,SAAOA,KAAK,GAAGD,MAAf;AACA;AAGD;AACA;AACA;AACA;;MACaM,WAAW,GAAG,CAACd,GAAD,EAAyBe,GAAzB,KAAwC;AAClE,MAAIhE,KAAK,GAAGiD,GAAG,CAACe,GAAD,CAAf;AAEA,MAAI,OAAOhE,KAAP,IAAgB,UAApB,EAAiC,OAAOA,KAAP;;AAEjC,MAAIA,KAAK,IAAI,CAACnC,KAAK,CAACoG,OAAN,CAAcjE,KAAd,CAAd,EAAoC;AACnCiD,IAAAA,GAAG,CAACe,GAAD,CAAH,GAAW,CAAChE,KAAD,CAAX;AACA;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;MACakE,OAAO,GAAG,CAACC,MAAD,EAA+BC,QAA/B,KAAqE;AAE3F,MAAKvG,KAAK,CAACoG,OAAN,CAAcE,MAAd,CAAL,EAA4B;AAC3BA,IAAAA,MAAM,CAACE,OAAP,CAAeD,QAAf;AAEA,GAHD,MAGK;AAEJ,SAAK,IAAIJ,GAAT,IAAgBG,MAAhB,EAAwB;AACvB,UAAIA,MAAM,CAACG,cAAP,CAAsBN,GAAtB,CAAJ,EAAgC;AAC/BI,QAAAA,QAAQ,CAACD,MAAM,CAACH,GAAD,CAAP,EAAcA,GAAd,CAAR;AACA;AACD;AACD;AACD;MAIYO,GAAG,GAAG,CAACnE,CAAD,EAAkBD,CAAlB,KAAsC;AACxD,MAAI,OAAOC,CAAP,KAAa,QAAb,IAAyB,OAAOD,CAAP,KAAa,QAA1C,EAAoD;AACnD,WAAOC,CAAC,GAAGD,CAAJ,GAAQ,CAAR,GAAaC,CAAC,GAAGD,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAAjC;AACA;;AACDC,EAAAA,CAAC,GAAGjB,SAAS,CAACiB,CAAC,GAAG,EAAL,CAAT,CAAkBoE,WAAlB,EAAJ;AACArE,EAAAA,CAAC,GAAGhB,SAAS,CAACgB,CAAC,GAAG,EAAL,CAAT,CAAkBqE,WAAlB,EAAJ;AACA,MAAIpE,CAAC,GAAGD,CAAR,EAAW,OAAO,CAAP;AACX,MAAIA,CAAC,GAAGC,CAAR,EAAW,OAAO,CAAC,CAAR;AACX,SAAO,CAAP;AACA;;ACtGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA,MAAMqE,MAAN,CAAY;AAEQ;;AAGnB;AACD;AACA;AACA;AACA;AACA;AACC9C,EAAAA,WAAW,CAAC+C,KAAD,EAAYC,QAAZ,EAAiC;AAAA,SATrCD,KASqC;AAAA,SARrCC,QAQqC;AAC3C,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKC,QAAL,GAAgBA,QAAQ,IAAI;AAACC,MAAAA,UAAU,EAAE;AAAb,KAA5B;AACA;;AAED;AACD;AACA;AACA;AACA;AACCC,EAAAA,QAAQ,CAACC,KAAD,EAAeC,uBAAf,EAAiDC,OAAjD,EAAgF;AACvF,QAAI,CAACF,KAAD,IAAU,CAACA,KAAK,CAAChD,MAArB,EAA6B,OAAO,EAAP;AAE7B,UAAMmD,MAAgB,GAAG,EAAzB;AACA,UAAMC,KAAK,GAAMJ,KAAK,CAACzB,KAAN,CAAY,KAAZ,CAAjB;AACA,QAAI8B,WAAJ;;AAEA,QAAIH,OAAJ,EAAa;AACZG,MAAAA,WAAW,GAAG,IAAIC,MAAJ,CAAY,OAAMxG,MAAM,CAACyG,IAAP,CAAYL,OAAZ,EAAqBM,GAArB,CAAyB9H,YAAzB,EAAuC+H,IAAvC,CAA4C,GAA5C,CAAN,GAAuD,UAAnE,CAAd;AACA;;AAEDL,IAAAA,KAAK,CAACb,OAAN,CAAemB,IAAD,IAAiB;AAC9B,UAAIC,WAAJ;AACA,UAAIC,KAAiB,GAAG,IAAxB;AACA,UAAI9B,KAAiB,GAAG,IAAxB,CAH8B;;AAM9B,UAAIuB,WAAW,KAAKM,WAAW,GAAGD,IAAI,CAAC9C,KAAL,CAAWyC,WAAX,CAAnB,CAAf,EAA4D;AAC3DO,QAAAA,KAAK,GAAGD,WAAW,CAAC,CAAD,CAAnB;AACAD,QAAAA,IAAI,GAAGC,WAAW,CAAC,CAAD,CAAlB;AACA;;AAED,UAAID,IAAI,CAAC1D,MAAL,GAAc,CAAlB,EAAqB;AACpB,YAAI,KAAK6C,QAAL,CAAcC,UAAlB,EAA8B;AAC7BhB,UAAAA,KAAK,GAAGnB,UAAU,CAAC+C,IAAD,CAAV,IAAoB,IAA5B;AACA,SAFD,MAEK;AACJ5B,UAAAA,KAAK,GAAGpG,YAAY,CAACgI,IAAD,CAApB;AACA;;AACD,YAAI5B,KAAK,IAAImB,uBAAb,EAAuCnB,KAAK,GAAG,QAAMA,KAAd;AACvC;;AAEDqB,MAAAA,MAAM,CAACU,IAAP,CAAY;AACX7B,QAAAA,MAAM,EAAG0B,IADE;AAEX5B,QAAAA,KAAK,EAAIA,KAAK,GAAG,IAAIwB,MAAJ,CAAWxB,KAAX,EAAiB,IAAjB,CAAH,GAA4B,IAF/B;AAGX8B,QAAAA,KAAK,EAAIA;AAHE,OAAZ;AAKA,KAzBD;AA2BA,WAAOT,MAAP;AACA;;AAGD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACCW,EAAAA,gBAAgB,CAACd,KAAD,EAAee,OAAf,EAAsC;AACrD,QAAIhC,MAAM,GAAG,KAAKiC,aAAL,CAAmBhB,KAAnB,EAA0Be,OAA1B,CAAb;AACA,WAAO,KAAKE,iBAAL,CAAuBlC,MAAvB,CAAP;AACA;AAED;AACD;AACA;AACA;;;AACCkC,EAAAA,iBAAiB,CAAClC,MAAD,EAAsB;AACtC,UAAMoB,MAAM,GAAIpB,MAAM,CAACoB,MAAvB;AAAA,UACAe,WAAW,GAAKf,MAAM,CAACnD,MADvB;;AAGA,QAAI,CAACkE,WAAL,EAAkB;AACjB,aAAO,YAAW;AAAE,eAAO,CAAP;AAAW,OAA/B;AACA;;AAED,UAAMC,MAAM,GAAGpC,MAAM,CAACgC,OAAP,CAAeI,MAA9B;AAAA,UACAjB,OAAO,GAAKnB,MAAM,CAACmB,OADnB;AAAA,UAEAkB,WAAW,GAAID,MAAM,CAACnE,MAFtB;AAAA,UAGAqE,SAAS,GAAItC,MAAM,CAACsC,SAHpB;;AAKA,QAAI,CAACD,WAAL,EAAkB;AACjB,aAAO,YAAW;AAAE,eAAO,CAAP;AAAW,OAA/B;AACA;AAGD;AACF;AACA;AACA;AACA;;;AACE,UAAME,WAAW,GAAI,YAAW;AAG/B,UAAIF,WAAW,KAAK,CAApB,EAAuB;AACtB,eAAO,UAAS1C,KAAT,EAAwB6C,IAAxB,EAAiC;AACvC,gBAAMX,KAAK,GAAGO,MAAM,CAAC,CAAD,CAAN,CAAWP,KAAzB;AACA,iBAAOnC,UAAU,CAAC4C,SAAS,CAACE,IAAD,EAAOX,KAAP,CAAV,EAAyBlC,KAAzB,EAAgCwB,OAAO,CAACU,KAAD,CAAP,IAAgB,CAAhD,CAAjB;AACA,SAHD;AAIA;;AAED,aAAO,UAASlC,KAAT,EAAwB6C,IAAxB,EAAiC;AACvC,YAAIC,GAAG,GAAG,CAAV,CADuC;;AAIvC,YAAI9C,KAAK,CAACkC,KAAV,EAAiB;AAEhB,gBAAM1F,KAAK,GAAGmG,SAAS,CAACE,IAAD,EAAO7C,KAAK,CAACkC,KAAb,CAAvB;;AAEA,cAAI,CAAClC,KAAK,CAACI,KAAP,IAAgB5D,KAApB,EAA2B;AAC1BsG,YAAAA,GAAG,IAAK,IAAEJ,WAAV;AACA,WAFD,MAEK;AACJI,YAAAA,GAAG,IAAI/C,UAAU,CAACvD,KAAD,EAAQwD,KAAR,EAAe,CAAf,CAAjB;AACA;AAID,SAZD,MAYK;AACJU,UAAAA,OAAO,CAACc,OAAD,EAAU,CAACvB,MAAD,EAAgBiC,KAAhB,KAAiC;AACjDY,YAAAA,GAAG,IAAI/C,UAAU,CAAC4C,SAAS,CAACE,IAAD,EAAOX,KAAP,CAAV,EAAyBlC,KAAzB,EAAgCC,MAAhC,CAAjB;AACA,WAFM,CAAP;AAGA;;AAED,eAAO6C,GAAG,GAAGJ,WAAb;AACA,OAvBD;AAwBA,KAlCmB,EAApB;;AAoCA,QAAIF,WAAW,KAAK,CAApB,EAAuB;AACtB,aAAO,UAASK,IAAT,EAAkB;AACxB,eAAOD,WAAW,CAACnB,MAAM,CAAC,CAAD,CAAP,EAAaoB,IAAb,CAAlB;AACA,OAFD;AAGA;;AAED,QAAIxC,MAAM,CAACgC,OAAP,CAAeU,WAAf,KAA+B,KAAnC,EAA0C;AACzC,aAAO,UAASF,IAAT,EAAkB;AACxB,YAAI3C,KAAJ;AAAA,YAAW4C,GAAG,GAAG,CAAjB;;AACA,aAAK,IAAI9C,KAAT,IAAkByB,MAAlB,EAAyB;AACxBvB,UAAAA,KAAK,GAAG0C,WAAW,CAAC5C,KAAD,EAAQ6C,IAAR,CAAnB;AACA,cAAI3C,KAAK,IAAI,CAAb,EAAgB,OAAO,CAAP;AAChB4C,UAAAA,GAAG,IAAI5C,KAAP;AACA;;AACD,eAAO4C,GAAG,GAAGN,WAAb;AACA,OARD;AASA,KAVD,MAUO;AACN,aAAO,UAASK,IAAT,EAAkB;AACxB,YAAIC,GAAG,GAAG,CAAV;AACApC,QAAAA,OAAO,CAACe,MAAD,EAASzB,KAAD,IAAiB;AAC/B8C,UAAAA,GAAG,IAAIF,WAAW,CAAC5C,KAAD,EAAQ6C,IAAR,CAAlB;AACA,SAFM,CAAP;AAGA,eAAOC,GAAG,GAAGN,WAAb;AACA,OAND;AAOA;AACD;;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACCQ,EAAAA,eAAe,CAAC1B,KAAD,EAAee,OAAf,EAAsC;AACpD,QAAIhC,MAAM,GAAI,KAAKiC,aAAL,CAAmBhB,KAAnB,EAA0Be,OAA1B,CAAd;AACA,WAAO,KAAKY,gBAAL,CAAsB5C,MAAtB,CAAP;AACA;;AAED4C,EAAAA,gBAAgB,CAAC5C,MAAD,EAAqB;AACpC,QAAI6C,cAAJ;AAAA,QACAC,SAAkB,GAAG,EADrB;AAGA,UAAMC,IAAI,GAAG,IAAb;AAAA,UACAf,OAAO,GAAIhC,MAAM,CAACgC,OADlB;AAAA,UAEAgB,IAAI,GAAK,CAAChD,MAAM,CAACiB,KAAR,IAAiBe,OAAO,CAACiB,UAA1B,GAAwCjB,OAAO,CAACiB,UAAhD,GAA6DjB,OAAO,CAACgB,IAF7E;;AAKA,QAAI,OAAOA,IAAP,IAAe,UAAnB,EAA+B;AAC9B,aAAOA,IAAI,CAACE,IAAL,CAAU,IAAV,CAAP;AACA;AAED;AACF;AACA;AACA;AACA;;;AACE,UAAMC,SAAS,GAAG,SAAZA,SAAY,CAAS9D,IAAT,EAAsBlF,MAAtB,EAAyD;AAC1E,UAAIkF,IAAI,KAAK,QAAb,EAAuB,OAAOlF,MAAM,CAAC0F,KAAd;AACvB,aAAOG,MAAM,CAACsC,SAAP,CAAiBS,IAAI,CAAClC,KAAL,CAAW1G,MAAM,CAACiJ,EAAlB,CAAjB,EAAwC/D,IAAxC,CAAP;AACA,KAHD,CAlBoC;;;AAwBpC,QAAI2D,IAAJ,EAAU;AACT,WAAK,IAAIK,CAAT,IAAcL,IAAd,EAAoB;AACnB,YAAIhD,MAAM,CAACiB,KAAP,IAAgBoC,CAAC,CAACxB,KAAF,KAAY,QAAhC,EAA0C;AACzCiB,UAAAA,SAAS,CAAChB,IAAV,CAAeuB,CAAf;AACA;AACD;AACD,KA9BmC;AAiCpC;;;AACA,QAAIrD,MAAM,CAACiB,KAAX,EAAkB;AACjB4B,MAAAA,cAAc,GAAG,IAAjB;;AACA,WAAK,IAAIS,GAAT,IAAgBR,SAAhB,EAA2B;AAC1B,YAAIQ,GAAG,CAACzB,KAAJ,KAAc,QAAlB,EAA4B;AAC3BgB,UAAAA,cAAc,GAAG,KAAjB;AACA;AACA;AACD;;AACD,UAAIA,cAAJ,EAAoB;AACnBC,QAAAA,SAAS,CAACS,OAAV,CAAkB;AAAC1B,UAAAA,KAAK,EAAE,QAAR;AAAkB2B,UAAAA,SAAS,EAAE;AAA7B,SAAlB;AACA,OAVgB;;AAajB,KAbD,MAaO;AACNV,MAAAA,SAAS,GAAGA,SAAS,CAACpF,MAAV,CAAkB4F,GAAD,IAASA,GAAG,CAACzB,KAAJ,KAAc,QAAxC,CAAZ;AACA,KAjDmC;;;AAqDpC,UAAM4B,eAAe,GAAGX,SAAS,CAAC7E,MAAlC;;AACA,QAAI,CAACwF,eAAL,EAAsB;AACrB,aAAO,IAAP;AACA;;AAED,WAAO,UAASlH,CAAT,EAAyBD,CAAzB,EAAyC;AAC/C,UAAInC,MAAJ,EAAY0H,KAAZ;;AACA,WAAK,IAAI6B,QAAT,IAAqBZ,SAArB,EAAgC;AAC/BjB,QAAAA,KAAK,GAAG6B,QAAQ,CAAC7B,KAAjB;AAEA,YAAI8B,UAAU,GAAGD,QAAQ,CAACF,SAAT,KAAuB,MAAvB,GAAgC,CAAC,CAAjC,GAAqC,CAAtD;AAEArJ,QAAAA,MAAM,GAAGwJ,UAAU,GAAGjD,GAAG,CACxByC,SAAS,CAACtB,KAAD,EAAQtF,CAAR,CADe,EAExB4G,SAAS,CAACtB,KAAD,EAAQvF,CAAR,CAFe,CAAzB;AAIA,YAAInC,MAAJ,EAAY,OAAOA,MAAP;AACZ;;AACD,aAAO,CAAP;AACA,KAdD;AAgBA;;AAED;AACD;AACA;AACA;AACA;AACA;AACC8H,EAAAA,aAAa,CAAChB,KAAD,EAAe2C,QAAf,EAAoD;AAChE,UAAMzC,OAAiB,GAAG,EAA1B;AACA,QAAIa,OAAO,GAAIjH,MAAM,CAAC8I,MAAP,CAAc,EAAd,EAAiBD,QAAjB,CAAf;AAEA1D,IAAAA,WAAW,CAAC8B,OAAD,EAAS,MAAT,CAAX;AACA9B,IAAAA,WAAW,CAAC8B,OAAD,EAAS,YAAT,CAAX,CALgE;;AAQhE,QAAIA,OAAO,CAACI,MAAZ,EAAoB;AACnBlC,MAAAA,WAAW,CAAC8B,OAAD,EAAS,QAAT,CAAX;AACA,YAAMI,MAAgB,GAAG,EAAzB;AACAJ,MAAAA,OAAO,CAACI,MAAR,CAAe5B,OAAf,CAAwBqB,KAAD,IAA0B;AAChD,YAAI,OAAOA,KAAP,IAAgB,QAApB,EAA8B;AAC7BA,UAAAA,KAAK,GAAG;AAACA,YAAAA,KAAK,EAACA,KAAP;AAAajC,YAAAA,MAAM,EAAC;AAApB,WAAR;AACA;;AACDwC,QAAAA,MAAM,CAACN,IAAP,CAAYD,KAAZ;AACAV,QAAAA,OAAO,CAACU,KAAK,CAACA,KAAP,CAAP,GAAwB,YAAYA,KAAb,GAAsBA,KAAK,CAACjC,MAA5B,GAAqC,CAA5D;AACA,OAND;AAOAoC,MAAAA,OAAO,CAACI,MAAR,GAAiBA,MAAjB;AACA;;AAGD,WAAO;AACNJ,MAAAA,OAAO,EAAIA,OADL;AAENf,MAAAA,KAAK,EAAIA,KAAK,CAACN,WAAN,GAAoBmD,IAApB,EAFH;AAGN1C,MAAAA,MAAM,EAAI,KAAKJ,QAAL,CAAcC,KAAd,EAAqBe,OAAO,CAACd,uBAA7B,EAAsDC,OAAtD,CAHJ;AAIN4C,MAAAA,KAAK,EAAI,CAJH;AAKNlD,MAAAA,KAAK,EAAI,EALH;AAMNM,MAAAA,OAAO,EAAIA,OANL;AAONmB,MAAAA,SAAS,EAAIN,OAAO,CAACgC,OAAT,GAAoB1E,cAApB,GAAqCH;AAP3C,KAAP;AASA;;AAED;AACD;AACA;AACA;AACCa,EAAAA,MAAM,CAACiB,KAAD,EAAee,OAAf,EAAqD;AAC1D,QAAIe,IAAI,GAAG,IAAX;AAAA,QAAiBlD,KAAjB;AAAA,QAAwBG,MAAxB;AAEAA,IAAAA,MAAM,GAAI,KAAKiC,aAAL,CAAmBhB,KAAnB,EAA0Be,OAA1B,CAAV;AACAA,IAAAA,OAAO,GAAGhC,MAAM,CAACgC,OAAjB;AACAf,IAAAA,KAAK,GAAKjB,MAAM,CAACiB,KAAjB,CAL0D;;AAQ1D,UAAMgD,QAAkB,GAAGjC,OAAO,CAACnC,KAAR,IAAiBkD,IAAI,CAACb,iBAAL,CAAuBlC,MAAvB,CAA5C,CAR0D;;;AAW1D,QAAIiB,KAAK,CAAChD,MAAV,EAAkB;AACjBoC,MAAAA,OAAO,CAAC0C,IAAI,CAAClC,KAAN,EAAa,CAACqD,IAAD,EAAoBd,EAApB,KAAyC;AAC5DvD,QAAAA,KAAK,GAAGoE,QAAQ,CAACC,IAAD,CAAhB;;AACA,YAAIlC,OAAO,CAACtE,MAAR,KAAmB,KAAnB,IAA4BmC,KAAK,GAAG,CAAxC,EAA2C;AAC1CG,UAAAA,MAAM,CAACa,KAAP,CAAaiB,IAAb,CAAkB;AAAC,qBAASjC,KAAV;AAAiB,kBAAMuD;AAAvB,WAAlB;AACA;AACD,OALM,CAAP;AAMA,KAPD,MAOO;AACN/C,MAAAA,OAAO,CAAC0C,IAAI,CAAClC,KAAN,EAAa,CAACsD,CAAD,EAAiBf,EAAjB,KAAsC;AACzDpD,QAAAA,MAAM,CAACa,KAAP,CAAaiB,IAAb,CAAkB;AAAC,mBAAS,CAAV;AAAa,gBAAMsB;AAAnB,SAAlB;AACA,OAFM,CAAP;AAGA;;AAED,UAAMgB,OAAO,GAAGrB,IAAI,CAACH,gBAAL,CAAsB5C,MAAtB,CAAhB;;AACA,QAAIoE,OAAJ,EAAapE,MAAM,CAACa,KAAP,CAAamC,IAAb,CAAkBoB,OAAlB,EAzB6C;;AA4B1DpE,IAAAA,MAAM,CAAC+D,KAAP,GAAe/D,MAAM,CAACa,KAAP,CAAa5C,MAA5B;;AACA,QAAI,OAAO+D,OAAO,CAACqC,KAAf,KAAyB,QAA7B,EAAuC;AACtCrE,MAAAA,MAAM,CAACa,KAAP,GAAeb,MAAM,CAACa,KAAP,CAAayD,KAAb,CAAmB,CAAnB,EAAsBtC,OAAO,CAACqC,KAA9B,CAAf;AACA;;AAED,WAAOrE,MAAP;AACA;;AA3UU;;;;;;;;;;;"}