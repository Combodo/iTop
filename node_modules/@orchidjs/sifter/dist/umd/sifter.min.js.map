{"version":3,"file":"sifter.min.js","sources":["../../node_modules/@orchidjs/unicode-variants/dist/esm/regex.js","../../node_modules/@orchidjs/unicode-variants/dist/esm/strings.js","../../node_modules/@orchidjs/unicode-variants/dist/esm/index.js","../../lib/utils.ts","../../lib/sifter.ts"],"sourcesContent":["/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */\n/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n * \tex ['a','b'] => [ab]\n * @param {string[]} chars\n * @return {string}\n */\nconst arrayToPattern = chars => {\n  chars = chars.filter(Boolean);\n\n  if (chars.length < 2) {\n    return chars[0] || '';\n  }\n\n  return maxValueLength(chars) == 1 ? '[' + chars.join('') + ']' : '(?:' + chars.join('|') + ')';\n};\n/**\n * @param {string[]} array\n * @return {string}\n */\n\nconst sequencePattern = array => {\n  if (!hasDuplicates(array)) {\n    return array.join('');\n  }\n\n  let pattern = '';\n  let prev_char_count = 0;\n\n  const prev_pattern = () => {\n    if (prev_char_count > 1) {\n      pattern += '{' + prev_char_count + '}';\n    }\n  };\n\n  array.forEach((char, i) => {\n    if (char === array[i - 1]) {\n      prev_char_count++;\n      return;\n    }\n\n    prev_pattern();\n    pattern += char;\n    prev_char_count = 1;\n  });\n  prev_pattern();\n  return pattern;\n};\n/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n * \tex ['a','b'] => [ab]\n * @param {Set<string>} chars\n * @return {string}\n */\n\nconst setToPattern = chars => {\n  let array = toArray(chars);\n  return arrayToPattern(array);\n};\n/**\n *\n * https://stackoverflow.com/questions/7376598/in-javascript-how-do-i-check-if-an-array-has-duplicate-values\n * @param {any[]} array\n */\n\nconst hasDuplicates = array => {\n  return new Set(array).size !== array.length;\n};\n/**\n * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error\n * @param {string} str\n * @return {string}\n */\n\nconst escape_regex = str => {\n  return (str + '').replace(/([\\$\\(\\)\\*\\+\\.\\?\\[\\]\\^\\{\\|\\}\\\\])/gu, '\\\\$1');\n};\n/**\n * Return the max length of array values\n * @param {string[]} array\n *\n */\n\nconst maxValueLength = array => {\n  return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);\n};\n/**\n * @param {string} str\n */\n\nconst unicodeLength = str => {\n  return toArray(str).length;\n};\n/**\n * @param {any} p\n * @return {any[]}\n */\n\nconst toArray = p => Array.from(p);\n\nexport { arrayToPattern, escape_regex, hasDuplicates, maxValueLength, sequencePattern, setToPattern, toArray, unicodeLength };\n//# sourceMappingURL=regex.js.map\n","/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */\n/**\n * Get all possible combinations of substrings that add up to the given string\n * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string\n * @param {string} input\n * @return {string[][]}\n */\nconst allSubstrings = input => {\n  if (input.length === 1) return [[input]];\n  /** @type {string[][]} */\n\n  let result = [];\n  const start = input.substring(1);\n  const suba = allSubstrings(start);\n  suba.forEach(function (subresult) {\n    let tmp = subresult.slice(0);\n    tmp[0] = input.charAt(0) + tmp[0];\n    result.push(tmp);\n    tmp = subresult.slice(0);\n    tmp.unshift(input.charAt(0));\n    result.push(tmp);\n  });\n  return result;\n};\n\nexport { allSubstrings };\n//# sourceMappingURL=strings.js.map\n","/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */\nimport { toArray, setToPattern, escape_regex, arrayToPattern, sequencePattern } from './regex.js';\nexport { escape_regex } from './regex.js';\nimport { allSubstrings } from './strings.js';\n\n/**\n * @typedef {{[key:string]:string}} TUnicodeMap\n * @typedef {{[key:string]:Set<string>}} TUnicodeSets\n * @typedef {[[number,number]]} TCodePoints\n * @typedef {{folded:string,composed:string,code_point:number}} TCodePointObj\n * @typedef {{start:number,end:number,length:number,substr:string}} TSequencePart\n */\n/** @type {TCodePoints} */\n\nconst code_points = [[0, 65535]];\nconst accent_pat = '[\\u0300-\\u036F\\u{b7}\\u{2be}\\u{2bc}]';\n/** @type {TUnicodeMap} */\n\nlet unicode_map;\n/** @type {RegExp} */\n\nlet multi_char_reg;\nconst max_char_length = 3;\n/** @type {TUnicodeMap} */\n\nconst latin_convert = {};\n/** @type {TUnicodeMap} */\n\nconst latin_condensed = {\n  '/': '⁄∕',\n  '0': '߀',\n  \"a\": \"ⱥɐɑ\",\n  \"aa\": \"ꜳ\",\n  \"ae\": \"æǽǣ\",\n  \"ao\": \"ꜵ\",\n  \"au\": \"ꜷ\",\n  \"av\": \"ꜹꜻ\",\n  \"ay\": \"ꜽ\",\n  \"b\": \"ƀɓƃ\",\n  \"c\": \"ꜿƈȼↄ\",\n  \"d\": \"đɗɖᴅƌꮷԁɦ\",\n  \"e\": \"ɛǝᴇɇ\",\n  \"f\": \"ꝼƒ\",\n  \"g\": \"ǥɠꞡᵹꝿɢ\",\n  \"h\": \"ħⱨⱶɥ\",\n  \"i\": \"ɨı\",\n  \"j\": \"ɉȷ\",\n  \"k\": \"ƙⱪꝁꝃꝅꞣ\",\n  \"l\": \"łƚɫⱡꝉꝇꞁɭ\",\n  \"m\": \"ɱɯϻ\",\n  \"n\": \"ꞥƞɲꞑᴎлԉ\",\n  \"o\": \"øǿɔɵꝋꝍᴑ\",\n  \"oe\": \"œ\",\n  \"oi\": \"ƣ\",\n  \"oo\": \"ꝏ\",\n  \"ou\": \"ȣ\",\n  \"p\": \"ƥᵽꝑꝓꝕρ\",\n  \"q\": \"ꝗꝙɋ\",\n  \"r\": \"ɍɽꝛꞧꞃ\",\n  \"s\": \"ßȿꞩꞅʂ\",\n  \"t\": \"ŧƭʈⱦꞇ\",\n  \"th\": \"þ\",\n  \"tz\": \"ꜩ\",\n  \"u\": \"ʉ\",\n  \"v\": \"ʋꝟʌ\",\n  \"vy\": \"ꝡ\",\n  \"w\": \"ⱳ\",\n  \"y\": \"ƴɏỿ\",\n  \"z\": \"ƶȥɀⱬꝣ\",\n  \"hv\": \"ƕ\"\n};\n\nfor (let latin in latin_condensed) {\n  let unicode = latin_condensed[latin] || '';\n\n  for (let i = 0; i < unicode.length; i++) {\n    let char = unicode.substring(i, i + 1);\n    latin_convert[char] = latin;\n  }\n}\n\nconst convert_pat = new RegExp(Object.keys(latin_convert).join('|') + '|' + accent_pat, 'gu');\n/**\n * Initialize the unicode_map from the give code point ranges\n *\n * @param {TCodePoints=} _code_points\n */\n\nconst initialize = _code_points => {\n  if (unicode_map !== undefined) return;\n  unicode_map = generateMap(_code_points || code_points);\n};\n/**\n * Helper method for normalize a string\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\n * @param {string} str\n * @param {string} form\n */\n\nconst normalize = (str, form = 'NFKD') => str.normalize(form);\n/**\n * Remove accents without reordering string\n * calling str.normalize('NFKD') on \\u{594}\\u{595}\\u{596} becomes \\u{596}\\u{594}\\u{595}\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n * @param {string} str\n * @return {string}\n */\n\nconst asciifold = str => {\n  return toArray(str).reduce(\n  /**\n   * @param {string} result\n   * @param {string} char\n   */\n  (result, char) => {\n    return result + _asciifold(char);\n  }, '');\n};\n/**\n * @param {string} str\n * @return {string}\n */\n\nconst _asciifold = str => {\n  str = normalize(str).toLowerCase().replace(convert_pat, (\n  /** @type {string} */\n  char) => {\n    return latin_convert[char] || '';\n  }); //return str;\n\n  return normalize(str, 'NFC');\n};\n/**\n * Generate a list of unicode variants from the list of code points\n * @param {TCodePoints} code_points\n * @yield {TCodePointObj}\n */\n\nfunction* generator(code_points) {\n  for (const [code_point_min, code_point_max] of code_points) {\n    for (let i = code_point_min; i <= code_point_max; i++) {\n      let composed = String.fromCharCode(i);\n      let folded = asciifold(composed);\n\n      if (folded == composed.toLowerCase()) {\n        continue;\n      } // skip when folded is a string longer than 3 characters long\n      // bc the resulting regex patterns will be long\n      // eg:\n      // folded صلى الله عليه وسلم length 18 code point 65018\n      // folded جل جلاله length 8 code point 65019\n\n\n      if (folded.length > max_char_length) {\n        continue;\n      }\n\n      if (folded.length == 0) {\n        continue;\n      }\n\n      yield {\n        folded: folded,\n        composed: composed,\n        code_point: i\n      };\n    }\n  }\n}\n/**\n * Generate a unicode map from the list of code points\n * @param {TCodePoints} code_points\n * @return {TUnicodeSets}\n */\n\nconst generateSets = code_points => {\n  /** @type {{[key:string]:Set<string>}} */\n  const unicode_sets = {};\n  /**\n   * @param {string} folded\n   * @param {string} to_add\n   */\n\n  const addMatching = (folded, to_add) => {\n    /** @type {Set<string>} */\n    const folded_set = unicode_sets[folded] || new Set();\n    const patt = new RegExp('^' + setToPattern(folded_set) + '$', 'iu');\n\n    if (to_add.match(patt)) {\n      return;\n    }\n\n    folded_set.add(escape_regex(to_add));\n    unicode_sets[folded] = folded_set;\n  };\n\n  for (let value of generator(code_points)) {\n    addMatching(value.folded, value.folded);\n    addMatching(value.folded, value.composed);\n  }\n\n  return unicode_sets;\n};\n/**\n * Generate a unicode map from the list of code points\n * ae => (?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))\n *\n * @param {TCodePoints} code_points\n * @return {TUnicodeMap}\n */\n\nconst generateMap = code_points => {\n  /** @type {TUnicodeSets} */\n  const unicode_sets = generateSets(code_points);\n  /** @type {TUnicodeMap} */\n\n  const unicode_map = {};\n  /** @type {string[]} */\n\n  let multi_char = [];\n\n  for (let folded in unicode_sets) {\n    let set = unicode_sets[folded];\n\n    if (set) {\n      unicode_map[folded] = setToPattern(set);\n    }\n\n    if (folded.length > 1) {\n      multi_char.push(escape_regex(folded));\n    }\n  }\n\n  multi_char.sort((a, b) => b.length - a.length);\n  const multi_char_patt = arrayToPattern(multi_char);\n  multi_char_reg = new RegExp('^' + multi_char_patt, 'u');\n  return unicode_map;\n};\n/**\n * Map each element of an array from it's folded value to all possible unicode matches\n * @param {string[]} strings\n * @param {number} min_replacement\n * @return {string}\n */\n\nconst mapSequence = (strings, min_replacement = 1) => {\n  let chars_replaced = 0;\n  strings = strings.map(str => {\n    if (unicode_map[str]) {\n      chars_replaced += str.length;\n    }\n\n    return unicode_map[str] || str;\n  });\n\n  if (chars_replaced >= min_replacement) {\n    return sequencePattern(strings);\n  }\n\n  return '';\n};\n/**\n * Convert a short string and split it into all possible patterns\n * Keep a pattern only if min_replacement is met\n *\n * 'abc'\n * \t\t=> [['abc'],['ab','c'],['a','bc'],['a','b','c']]\n *\t\t=> ['abc-pattern','ab-c-pattern'...]\n *\n *\n * @param {string} str\n * @param {number} min_replacement\n * @return {string}\n */\n\nconst substringsToPattern = (str, min_replacement = 1) => {\n  min_replacement = Math.max(min_replacement, str.length - 1);\n  return arrayToPattern(allSubstrings(str).map(sub_pat => {\n    return mapSequence(sub_pat, min_replacement);\n  }));\n};\n/**\n * Convert an array of sequences into a pattern\n * [{start:0,end:3,length:3,substr:'iii'}...] => (?:iii...)\n *\n * @param {Sequence[]} sequences\n * @param {boolean} all\n */\n\nconst sequencesToPattern = (sequences, all = true) => {\n  let min_replacement = sequences.length > 1 ? 1 : 0;\n  return arrayToPattern(sequences.map(sequence => {\n    let seq = [];\n    const len = all ? sequence.length() : sequence.length() - 1;\n\n    for (let j = 0; j < len; j++) {\n      seq.push(substringsToPattern(sequence.substrs[j] || '', min_replacement));\n    }\n\n    return sequencePattern(seq);\n  }));\n};\n/**\n * Return true if the sequence is already in the sequences\n * @param {Sequence} needle_seq\n * @param {Sequence[]} sequences\n */\n\n\nconst inSequences = (needle_seq, sequences) => {\n  for (const seq of sequences) {\n    if (seq.start != needle_seq.start || seq.end != needle_seq.end) {\n      continue;\n    }\n\n    if (seq.substrs.join('') !== needle_seq.substrs.join('')) {\n      continue;\n    }\n\n    let needle_parts = needle_seq.parts;\n    /**\n     * @param {TSequencePart} part\n     */\n\n    const filter = part => {\n      for (const needle_part of needle_parts) {\n        if (needle_part.start === part.start && needle_part.substr === part.substr) {\n          return false;\n        }\n\n        if (part.length == 1 || needle_part.length == 1) {\n          continue;\n        } // check for overlapping parts\n        // a = ['::=','==']\n        // b = ['::','===']\n        // a = ['r','sm']\n        // b = ['rs','m']\n\n\n        if (part.start < needle_part.start && part.end > needle_part.start) {\n          return true;\n        }\n\n        if (needle_part.start < part.start && needle_part.end > part.start) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    let filtered = seq.parts.filter(filter);\n\n    if (filtered.length > 0) {\n      continue;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nclass Sequence {\n  constructor() {\n    /** @type {TSequencePart[]} */\n    this.parts = [];\n    /** @type {string[]} */\n\n    this.substrs = [];\n    this.start = 0;\n    this.end = 0;\n  }\n  /**\n   * @param {TSequencePart|undefined} part\n   */\n\n\n  add(part) {\n    if (part) {\n      this.parts.push(part);\n      this.substrs.push(part.substr);\n      this.start = Math.min(part.start, this.start);\n      this.end = Math.max(part.end, this.end);\n    }\n  }\n\n  last() {\n    return this.parts[this.parts.length - 1];\n  }\n\n  length() {\n    return this.parts.length;\n  }\n  /**\n   * @param {number} position\n   * @param {TSequencePart} last_piece\n   */\n\n\n  clone(position, last_piece) {\n    let clone = new Sequence();\n    let parts = JSON.parse(JSON.stringify(this.parts));\n    let last_part = parts.pop();\n\n    for (const part of parts) {\n      clone.add(part);\n    }\n\n    let last_substr = last_piece.substr.substring(0, position - last_part.start);\n    let clone_last_len = last_substr.length;\n    clone.add({\n      start: last_part.start,\n      end: last_part.start + clone_last_len,\n      length: clone_last_len,\n      substr: last_substr\n    });\n    return clone;\n  }\n\n}\n/**\n * Expand a regular expression pattern to include unicode variants\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n * Issue:\n *  ﺊﺋ [ 'ﺊ = \\\\u{fe8a}', 'ﺋ = \\\\u{fe8b}' ]\n *\tbecomes:\tئئ [ 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}', 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}' ]\n *\n *\tİĲ = IIJ = ⅡJ\n *\n * \t1/2/4\n *\n * @param {string} str\n * @return {string|undefined}\n */\n\n\nconst getPattern = str => {\n  initialize();\n  str = asciifold(str);\n  let pattern = '';\n  let sequences = [new Sequence()];\n\n  for (let i = 0; i < str.length; i++) {\n    let substr = str.substring(i);\n    let match = substr.match(multi_char_reg);\n    const char = str.substring(i, i + 1);\n    const match_str = match ? match[0] : null; // loop through sequences\n    // add either the char or multi_match\n\n    let overlapping = [];\n    let added_types = new Set();\n\n    for (const sequence of sequences) {\n      const last_piece = sequence.last();\n\n      if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {\n        // if we have a multi match\n        if (match_str) {\n          const len = match_str.length;\n          sequence.add({\n            start: i,\n            end: i + len,\n            length: len,\n            substr: match_str\n          });\n          added_types.add('1');\n        } else {\n          sequence.add({\n            start: i,\n            end: i + 1,\n            length: 1,\n            substr: char\n          });\n          added_types.add('2');\n        }\n      } else if (match_str) {\n        let clone = sequence.clone(i, last_piece);\n        const len = match_str.length;\n        clone.add({\n          start: i,\n          end: i + len,\n          length: len,\n          substr: match_str\n        });\n        overlapping.push(clone);\n      } else {\n        // don't add char\n        // adding would create invalid patterns: 234 => [2,34,4]\n        added_types.add('3');\n      }\n    } // if we have overlapping\n\n\n    if (overlapping.length > 0) {\n      // ['ii','iii'] before ['i','i','iii']\n      overlapping = overlapping.sort((a, b) => {\n        return a.length() - b.length();\n      });\n\n      for (let clone of overlapping) {\n        // don't add if we already have an equivalent sequence\n        if (inSequences(clone, sequences)) {\n          continue;\n        }\n\n        sequences.push(clone);\n      }\n\n      continue;\n    } // if we haven't done anything unique\n    // clean up the patterns\n    // helps keep patterns smaller\n    // if str = 'r₨㎧aarss', pattern will be 446 instead of 655\n\n\n    if (i > 0 && added_types.size == 1 && !added_types.has('3')) {\n      pattern += sequencesToPattern(sequences, false);\n      let new_seq = new Sequence();\n      const old_seq = sequences[0];\n\n      if (old_seq) {\n        new_seq.add(old_seq.last());\n      }\n\n      sequences = [new_seq];\n    }\n  }\n\n  pattern += sequencesToPattern(sequences, true);\n  return pattern;\n};\n\nexport { _asciifold, asciifold, code_points, generateMap, generateSets, generator, getPattern, initialize, mapSequence, normalize, substringsToPattern, unicode_map };\n//# sourceMappingURL=index.js.map\n","\nimport { asciifold } from '@orchidjs/unicode-variants';\nimport * as T from './types';\n\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttr = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    return obj[name];\n};\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttrNesting = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    var part, names = name.split(\".\");\n\twhile( (part = names.shift()) && (obj = obj[part]));\n    return obj;\n};\n\n/**\n * Calculates how close of a match the\n * given value is against a search token.\n *\n */\nexport const scoreValue = (value:string, token:T.Token, weight:number ):number => {\n\tvar score, pos;\n\n\tif (!value) return 0;\n\n\tvalue = value + '';\n\tif( token.regex == null ) return 0;\n\tpos = value.search(token.regex);\n\tif (pos === -1) return 0;\n\n\tscore = token.string.length / value.length;\n\tif (pos === 0) score += 0.5;\n\n\treturn score * weight;\n};\n\n\n/**\n * Cast object property to an array if it exists and has a value\n *\n */\nexport const propToArray = (obj:{[key:string]:any}, key:string) => {\n\tvar value = obj[key];\n\n\tif( typeof value == 'function' ) return value;\n\n\tif( value && !Array.isArray(value) ){\n\t\tobj[key] = [value];\n\t}\n}\n\n\n/**\n * Iterates over arrays and hashes.\n *\n * ```\n * iterate(this.items, function(item, id) {\n *    // invoked for each item\n * });\n * ```\n *\n */\nexport const iterate = (object:[]|{[key:string]:any}, callback:(value:any,key:any)=>any) => {\n\n\tif ( Array.isArray(object)) {\n\t\tobject.forEach(callback);\n\n\t}else{\n\n\t\tfor (var key in object) {\n\t\t\tif (object.hasOwnProperty(key)) {\n\t\t\t\tcallback(object[key], key);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nexport const cmp = (a:number|string, b:number|string) => {\n\tif (typeof a === 'number' && typeof b === 'number') {\n\t\treturn a > b ? 1 : (a < b ? -1 : 0);\n\t}\n\ta = asciifold(a + '').toLowerCase();\n\tb = asciifold(b + '').toLowerCase();\n\tif (a > b) return 1;\n\tif (b > a) return -1;\n\treturn 0;\n};\n","/**\n * sifter.js\n * Copyright (c) 2013–2020 Brian Reavis & contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n * @author Brian Reavis <brian@thirdroute.com>\n */\n\nimport { scoreValue, getAttr, getAttrNesting, propToArray, iterate, cmp } from './utils';\nimport { getPattern, escape_regex } from '@orchidjs/unicode-variants';\nimport * as T from './types';\n\nclass Sifter{\n\n\tpublic items: any; // []|{};\n\tpublic settings: T.Settings;\n\n\t/**\n\t * Textually searches arrays and hashes of objects\n\t * by property (or multiple properties). Designed\n\t * specifically for autocomplete.\n\t *\n\t */\n\tconstructor(items:any, settings:T.Settings) {\n\t\tthis.items = items;\n\t\tthis.settings = settings || {diacritics: true};\n\t};\n\n\t/**\n\t * Splits a search string into an array of individual\n\t * regexps to be used to match results.\n\t *\n\t */\n\ttokenize(query:string, respect_word_boundaries?:boolean, weights?:T.Weights ):T.Token[] {\n\t\tif (!query || !query.length) return [];\n\n\t\tconst tokens:T.Token[]\t= [];\n\t\tconst words\t\t\t\t= query.split(/\\s+/);\n\t\tvar field_regex:RegExp;\n\n\t\tif( weights ){\n\t\t\tfield_regex = new RegExp( '^('+ Object.keys(weights).map(escape_regex).join('|')+')\\:(.*)$');\n\t\t}\n\n\t\twords.forEach((word:string) => {\n\t\t\tlet field_match;\n\t\t\tlet field:null|string\t= null;\n\t\t\tlet regex:null|string\t= null;\n\n\t\t\t// look for \"field:query\" tokens\n\t\t\tif( field_regex && (field_match = word.match(field_regex)) ){\n\t\t\t\tfield\t= field_match[1]!;\n\t\t\t\tword\t= field_match[2]!;\n\t\t\t}\n\n\t\t\tif( word.length > 0 ){\n\t\t\t\tif( this.settings.diacritics ){\n\t\t\t\t\tregex = getPattern(word) || null;\n\t\t\t\t}else{\n\t\t\t\t\tregex = escape_regex(word);\n\t\t\t\t}\n\t\t\t\tif( regex && respect_word_boundaries ) regex = \"\\\\b\"+regex;\n\t\t\t}\n\n\t\t\ttokens.push({\n\t\t\t\tstring : word,\n\t\t\t\tregex  : regex ? new RegExp(regex,'iu') : null,\n\t\t\t\tfield  : field,\n\t\t\t});\n\t\t});\n\n\t\treturn tokens;\n\t};\n\n\n\t/**\n\t * Returns a function to be used to score individual results.\n\t *\n\t * Good matches will have a higher score than poor matches.\n\t * If an item is not a match, 0 will be returned by the function.\n\t *\n\t * @returns {T.ScoreFn}\n\t */\n\tgetScoreFunction(query:string, options:T.UserOptions ){\n\t\tvar search = this.prepareSearch(query, options);\n\t\treturn this._getScoreFunction(search);\n\t}\n\n\t/**\n\t * @returns {T.ScoreFn}\n\t *\n\t */\n\t_getScoreFunction(search:T.PrepareObj ){\n\t\tconst tokens\t\t= search.tokens,\n\t\ttoken_count\t\t\t= tokens.length;\n\n\t\tif (!token_count) {\n\t\t\treturn function() { return 0; };\n\t\t}\n\n\t\tconst fields\t= search.options.fields,\n\t\tweights\t\t\t= search.weights,\n\t\tfield_count\t\t= fields.length,\n\t\tgetAttrFn\t\t= search.getAttrFn;\n\n\t\tif (!field_count) {\n\t\t\treturn function() { return 1; };\n\t\t}\n\n\n\t\t/**\n\t\t * Calculates the score of an object\n\t\t * against the search query.\n\t\t *\n\t\t */\n\t\tconst scoreObject = (function() {\n\n\n\t\t\tif (field_count === 1) {\n\t\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\t\tconst field = fields[0]!.field;\n\t\t\t\t\treturn scoreValue(getAttrFn(data, field), token, weights[field]||1);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\tvar sum = 0;\n\n\t\t\t\t// is the token specific to a field?\n\t\t\t\tif( token.field ){\n\n\t\t\t\t\tconst value = getAttrFn(data, token.field);\n\n\t\t\t\t\tif( !token.regex && value ){\n\t\t\t\t\t\tsum += (1/field_count);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += scoreValue(value, token, 1);\n\t\t\t\t\t}\n\n\n\n\t\t\t\t}else{\n\t\t\t\t\titerate(weights, (weight:number, field:string) => {\n\t\t\t\t\t\tsum += scoreValue(getAttrFn(data, field), token, weight);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn sum / field_count;\n\t\t\t};\n\t\t})();\n\n\t\tif (token_count === 1) {\n\t\t\treturn function(data:{}) {\n\t\t\t\treturn scoreObject(tokens[0]!, data);\n\t\t\t};\n\t\t}\n\n\t\tif (search.options.conjunction === 'and') {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar score, sum = 0;\n\t\t\t\tfor( let token of tokens){\n\t\t\t\t\tscore = scoreObject(token, data);\n\t\t\t\t\tif (score <= 0) return 0;\n\t\t\t\t\tsum += score;\n\t\t\t\t}\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar sum = 0;\n\t\t\t\titerate(tokens,(token:T.Token)=>{\n\t\t\t\t\tsum += scoreObject(token, data);\n\t\t\t\t});\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Returns a function that can be used to compare two\n\t * results, for sorting purposes. If no sorting should\n\t * be performed, `null` will be returned.\n\t *\n\t * @return function(a,b)\n\t */\n\tgetSortFunction(query:string, options:T.UserOptions) {\n\t\tvar search  = this.prepareSearch(query, options);\n\t\treturn this._getSortFunction(search);\n\t}\n\n\t_getSortFunction(search:T.PrepareObj){\n\t\tvar implicit_score,\n\t\tsort_flds:T.Sort[]\t= [];\n\n\t\tconst self\t= this,\n\t\toptions\t\t= search.options,\n\t\tsort\t\t= (!search.query && options.sort_empty) ? options.sort_empty : options.sort;\n\n\n\t\tif( typeof sort == 'function' ){\n\t\t\treturn sort.bind(this);\n\t\t}\n\n\t\t/**\n\t\t * Fetches the specified sort field value\n\t\t * from a search result item.\n\t\t *\n\t\t */\n\t\tconst get_field = function(name:string, result:T.ResultItem):string|number {\n\t\t\tif (name === '$score') return result.score;\n\t\t\treturn search.getAttrFn(self.items[result.id], name);\n\t\t};\n\n\t\t// parse options\n\t\tif (sort) {\n\t\t\tfor( let s of sort ){\n\t\t\t\tif (search.query || s.field !== '$score') {\n\t\t\t\t\tsort_flds.push(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// the \"$score\" field is implied to be the primary\n\t\t// sort field, unless it's manually specified\n\t\tif (search.query) {\n\t\t\timplicit_score = true;\n\t\t\tfor( let fld of sort_flds ){\n\t\t\t\tif( fld.field === '$score' ){\n\t\t\t\t\timplicit_score = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (implicit_score) {\n\t\t\t\tsort_flds.unshift({field: '$score', direction: 'desc'});\n\t\t\t}\n\n\t\t// without a search.query, all items will have the same score\n\t\t} else {\n\t\t\tsort_flds = sort_flds.filter((fld) => fld.field !== '$score' );\n\t\t}\n\n\n\t\t// build function\n\t\tconst sort_flds_count = sort_flds.length;\n\t\tif (!sort_flds_count) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn function(a:T.ResultItem, b:T.ResultItem) {\n\t\t\tvar result, field;\n\t\t\tfor( let sort_fld of sort_flds ){\n\t\t\t\tfield = sort_fld.field;\n\n\t\t\t\tlet\tmultiplier = sort_fld.direction === 'desc' ? -1 : 1;\n\n\t\t\t\tresult = multiplier * cmp(\n\t\t\t\t\tget_field(field, a),\n\t\t\t\t\tget_field(field, b)\n\t\t\t\t);\n\t\t\t\tif (result) return result;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\n\t};\n\n\t/**\n\t * Parses a search query and returns an object\n\t * with tokens and fields ready to be populated\n\t * with results.\n\t *\n\t */\n\tprepareSearch(query:string, optsUser:T.UserOptions):T.PrepareObj {\n\t\tconst weights:T.Weights = {};\n\t\tvar options\t\t= Object.assign({},optsUser) as T.Options;\n\n\t\tpropToArray(options,'sort');\n\t\tpropToArray(options,'sort_empty');\n\n\t\t// convert fields to new format\n\t\tif( options.fields ){\n\t\t\tpropToArray(options,'fields');\n\t\t\tconst fields:T.Field[] = [];\n\t\t\toptions.fields.forEach((field:string|T.Field) => {\n\t\t\t\tif( typeof field == 'string' ){\n\t\t\t\t\tfield = {field:field,weight:1};\n\t\t\t\t}\n\t\t\t\tfields.push(field);\n\t\t\t\tweights[field.field] = ('weight' in field) ? field.weight : 1;\n\t\t\t});\n\t\t\toptions.fields = fields;\n\t\t}\n\n\n\t\treturn {\n\t\t\toptions\t\t: options as T.Options,\n\t\t\tquery\t\t: query.toLowerCase().trim(),\n\t\t\ttokens\t\t: this.tokenize(query, options.respect_word_boundaries, weights),\n\t\t\ttotal\t\t: 0,\n\t\t\titems\t\t: [],\n\t\t\tweights\t\t: weights,\n\t\t\tgetAttrFn\t: (options.nesting) ? getAttrNesting : getAttr,\n\t\t};\n\t};\n\n\t/**\n\t * Searches through all items and returns a sorted array of matches.\n\t *\n\t */\n\tsearch(query:string, options:T.UserOptions) : T.PrepareObj {\n\t\tvar self = this, score, search: T.PrepareObj;\n\n\t\tsearch  = this.prepareSearch(query, options);\n\t\toptions = search.options;\n\t\tquery   = search.query;\n\n\t\t// generate result scoring function\n\t\tconst fn_score:T.ScoreFn = options.score || self._getScoreFunction(search);\n\n\t\t// perform search and sort\n\t\tif (query.length) {\n\t\t\titerate(self.items, (item:T.ResultItem, id:string|number) => {\n\t\t\t\tscore = fn_score(item);\n\t\t\t\tif (options.filter === false || score > 0) {\n\t\t\t\t\tsearch.items.push({'score': score, 'id': id});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\titerate(self.items, (_:T.ResultItem, id:string|number) => {\n\t\t\t\tsearch.items.push({'score': 1, 'id': id});\n\t\t\t});\n\t\t}\n\n\t\tconst fn_sort = self._getSortFunction(search);\n\t\tif (fn_sort) search.items.sort(fn_sort);\n\n\t\t// apply limits\n\t\tsearch.total = search.items.length;\n\t\tif (typeof options.limit === 'number') {\n\t\t\tsearch.items = search.items.slice(0, options.limit);\n\t\t}\n\n\t\treturn search;\n\t};\n}\n\nexport { Sifter, scoreValue, getAttr, getAttrNesting, propToArray, iterate, cmp, getPattern }\n"],"names":["arrayToPattern","chars","maxValueLength","sequencePattern","array","hasDuplicates","pattern","prev_char_count","prev_pattern","char","i","setToPattern","toArray","Set","size","length","escape_regex","str","replace","longest","value","Math","unicodeLength","p","Array","allSubstrings","input","result","start","suba","subresult","tmp","code_points","unicode_map","multi_char_reg","latin_convert","latin_condensed","latin","unicode","convert_pat","RegExp","Object","normalize","form","asciifold","reduce","_asciifold","toLowerCase","generateSets","unicode_sets","addMatching","folded","to_add","folded_set","patt","code_point_min","code_point_max","composed","String","code_point","generator","generateMap","multi_char","set","a","b","multi_char_patt","substringsToPattern","min_replacement","map","sub_pat","strings","chars_replaced","mapSequence","sequencesToPattern","sequences","all","sequence","seq","len","j","inSequences","needle_seq","end","needle_parts","parts","filter","part","needle_part","substr","filtered","Sequence","constructor","substrs","add","push","this","last","clone","position","last_piece","JSON","last_part","pop","last_substr","clone_last_len","getPattern","_code_points","undefined","match","match_str","overlapping","added_types","sort","new_seq","old_seq","getAttr","obj","name","getAttrNesting","names","split","shift","scoreValue","token","weight","score","pos","regex","search","string","propToArray","key","isArray","iterate","object","callback","forEach","hasOwnProperty","cmp","items","settings","diacritics","tokenize","query","respect_word_boundaries","weights","tokens","words","field_regex","keys","join","word","field_match","field","getScoreFunction","options","prepareSearch","_getScoreFunction","token_count","fields","field_count","getAttrFn","scoreObject","data","sum","conjunction","getSortFunction","_getSortFunction","implicit_score","sort_flds","self","sort_empty","bind","get_field","id","s","fld","unshift","direction","sort_fld","optsUser","assign","trim","total","nesting","fn_score","item","_","fn_sort","limit","slice"],"mappings":"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"}