{"version":3,"file":"index.js","sources":["../../../../../../../node_modules/@orchidjs/unicode-variants/dist/esm/index.js"],"sourcesContent":["/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */\nimport { toArray, setToPattern, escape_regex, arrayToPattern, sequencePattern } from './regex.js';\nexport { escape_regex } from './regex.js';\nimport { allSubstrings } from './strings.js';\n\n/**\n * @typedef {{[key:string]:string}} TUnicodeMap\n * @typedef {{[key:string]:Set<string>}} TUnicodeSets\n * @typedef {[[number,number]]} TCodePoints\n * @typedef {{folded:string,composed:string,code_point:number}} TCodePointObj\n * @typedef {{start:number,end:number,length:number,substr:string}} TSequencePart\n */\n/** @type {TCodePoints} */\n\nconst code_points = [[0, 65535]];\nconst accent_pat = '[\\u0300-\\u036F\\u{b7}\\u{2be}\\u{2bc}]';\n/** @type {TUnicodeMap} */\n\nlet unicode_map;\n/** @type {RegExp} */\n\nlet multi_char_reg;\nconst max_char_length = 3;\n/** @type {TUnicodeMap} */\n\nconst latin_convert = {};\n/** @type {TUnicodeMap} */\n\nconst latin_condensed = {\n  '/': '⁄∕',\n  '0': '߀',\n  \"a\": \"ⱥɐɑ\",\n  \"aa\": \"ꜳ\",\n  \"ae\": \"æǽǣ\",\n  \"ao\": \"ꜵ\",\n  \"au\": \"ꜷ\",\n  \"av\": \"ꜹꜻ\",\n  \"ay\": \"ꜽ\",\n  \"b\": \"ƀɓƃ\",\n  \"c\": \"ꜿƈȼↄ\",\n  \"d\": \"đɗɖᴅƌꮷԁɦ\",\n  \"e\": \"ɛǝᴇɇ\",\n  \"f\": \"ꝼƒ\",\n  \"g\": \"ǥɠꞡᵹꝿɢ\",\n  \"h\": \"ħⱨⱶɥ\",\n  \"i\": \"ɨı\",\n  \"j\": \"ɉȷ\",\n  \"k\": \"ƙⱪꝁꝃꝅꞣ\",\n  \"l\": \"łƚɫⱡꝉꝇꞁɭ\",\n  \"m\": \"ɱɯϻ\",\n  \"n\": \"ꞥƞɲꞑᴎлԉ\",\n  \"o\": \"øǿɔɵꝋꝍᴑ\",\n  \"oe\": \"œ\",\n  \"oi\": \"ƣ\",\n  \"oo\": \"ꝏ\",\n  \"ou\": \"ȣ\",\n  \"p\": \"ƥᵽꝑꝓꝕρ\",\n  \"q\": \"ꝗꝙɋ\",\n  \"r\": \"ɍɽꝛꞧꞃ\",\n  \"s\": \"ßȿꞩꞅʂ\",\n  \"t\": \"ŧƭʈⱦꞇ\",\n  \"th\": \"þ\",\n  \"tz\": \"ꜩ\",\n  \"u\": \"ʉ\",\n  \"v\": \"ʋꝟʌ\",\n  \"vy\": \"ꝡ\",\n  \"w\": \"ⱳ\",\n  \"y\": \"ƴɏỿ\",\n  \"z\": \"ƶȥɀⱬꝣ\",\n  \"hv\": \"ƕ\"\n};\n\nfor (let latin in latin_condensed) {\n  let unicode = latin_condensed[latin] || '';\n\n  for (let i = 0; i < unicode.length; i++) {\n    let char = unicode.substring(i, i + 1);\n    latin_convert[char] = latin;\n  }\n}\n\nconst convert_pat = new RegExp(Object.keys(latin_convert).join('|') + '|' + accent_pat, 'gu');\n/**\n * Initialize the unicode_map from the give code point ranges\n *\n * @param {TCodePoints=} _code_points\n */\n\nconst initialize = _code_points => {\n  if (unicode_map !== undefined) return;\n  unicode_map = generateMap(_code_points || code_points);\n};\n/**\n * Helper method for normalize a string\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\n * @param {string} str\n * @param {string} form\n */\n\nconst normalize = (str, form = 'NFKD') => str.normalize(form);\n/**\n * Remove accents without reordering string\n * calling str.normalize('NFKD') on \\u{594}\\u{595}\\u{596} becomes \\u{596}\\u{594}\\u{595}\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n * @param {string} str\n * @return {string}\n */\n\nconst asciifold = str => {\n  return toArray(str).reduce(\n  /**\n   * @param {string} result\n   * @param {string} char\n   */\n  (result, char) => {\n    return result + _asciifold(char);\n  }, '');\n};\n/**\n * @param {string} str\n * @return {string}\n */\n\nconst _asciifold = str => {\n  str = normalize(str).toLowerCase().replace(convert_pat, (\n  /** @type {string} */\n  char) => {\n    return latin_convert[char] || '';\n  }); //return str;\n\n  return normalize(str, 'NFC');\n};\n/**\n * Generate a list of unicode variants from the list of code points\n * @param {TCodePoints} code_points\n * @yield {TCodePointObj}\n */\n\nfunction* generator(code_points) {\n  for (const [code_point_min, code_point_max] of code_points) {\n    for (let i = code_point_min; i <= code_point_max; i++) {\n      let composed = String.fromCharCode(i);\n      let folded = asciifold(composed);\n\n      if (folded == composed.toLowerCase()) {\n        continue;\n      } // skip when folded is a string longer than 3 characters long\n      // bc the resulting regex patterns will be long\n      // eg:\n      // folded صلى الله عليه وسلم length 18 code point 65018\n      // folded جل جلاله length 8 code point 65019\n\n\n      if (folded.length > max_char_length) {\n        continue;\n      }\n\n      if (folded.length == 0) {\n        continue;\n      }\n\n      yield {\n        folded: folded,\n        composed: composed,\n        code_point: i\n      };\n    }\n  }\n}\n/**\n * Generate a unicode map from the list of code points\n * @param {TCodePoints} code_points\n * @return {TUnicodeSets}\n */\n\nconst generateSets = code_points => {\n  /** @type {{[key:string]:Set<string>}} */\n  const unicode_sets = {};\n  /**\n   * @param {string} folded\n   * @param {string} to_add\n   */\n\n  const addMatching = (folded, to_add) => {\n    /** @type {Set<string>} */\n    const folded_set = unicode_sets[folded] || new Set();\n    const patt = new RegExp('^' + setToPattern(folded_set) + '$', 'iu');\n\n    if (to_add.match(patt)) {\n      return;\n    }\n\n    folded_set.add(escape_regex(to_add));\n    unicode_sets[folded] = folded_set;\n  };\n\n  for (let value of generator(code_points)) {\n    addMatching(value.folded, value.folded);\n    addMatching(value.folded, value.composed);\n  }\n\n  return unicode_sets;\n};\n/**\n * Generate a unicode map from the list of code points\n * ae => (?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))\n *\n * @param {TCodePoints} code_points\n * @return {TUnicodeMap}\n */\n\nconst generateMap = code_points => {\n  /** @type {TUnicodeSets} */\n  const unicode_sets = generateSets(code_points);\n  /** @type {TUnicodeMap} */\n\n  const unicode_map = {};\n  /** @type {string[]} */\n\n  let multi_char = [];\n\n  for (let folded in unicode_sets) {\n    let set = unicode_sets[folded];\n\n    if (set) {\n      unicode_map[folded] = setToPattern(set);\n    }\n\n    if (folded.length > 1) {\n      multi_char.push(escape_regex(folded));\n    }\n  }\n\n  multi_char.sort((a, b) => b.length - a.length);\n  const multi_char_patt = arrayToPattern(multi_char);\n  multi_char_reg = new RegExp('^' + multi_char_patt, 'u');\n  return unicode_map;\n};\n/**\n * Map each element of an array from it's folded value to all possible unicode matches\n * @param {string[]} strings\n * @param {number} min_replacement\n * @return {string}\n */\n\nconst mapSequence = (strings, min_replacement = 1) => {\n  let chars_replaced = 0;\n  strings = strings.map(str => {\n    if (unicode_map[str]) {\n      chars_replaced += str.length;\n    }\n\n    return unicode_map[str] || str;\n  });\n\n  if (chars_replaced >= min_replacement) {\n    return sequencePattern(strings);\n  }\n\n  return '';\n};\n/**\n * Convert a short string and split it into all possible patterns\n * Keep a pattern only if min_replacement is met\n *\n * 'abc'\n * \t\t=> [['abc'],['ab','c'],['a','bc'],['a','b','c']]\n *\t\t=> ['abc-pattern','ab-c-pattern'...]\n *\n *\n * @param {string} str\n * @param {number} min_replacement\n * @return {string}\n */\n\nconst substringsToPattern = (str, min_replacement = 1) => {\n  min_replacement = Math.max(min_replacement, str.length - 1);\n  return arrayToPattern(allSubstrings(str).map(sub_pat => {\n    return mapSequence(sub_pat, min_replacement);\n  }));\n};\n/**\n * Convert an array of sequences into a pattern\n * [{start:0,end:3,length:3,substr:'iii'}...] => (?:iii...)\n *\n * @param {Sequence[]} sequences\n * @param {boolean} all\n */\n\nconst sequencesToPattern = (sequences, all = true) => {\n  let min_replacement = sequences.length > 1 ? 1 : 0;\n  return arrayToPattern(sequences.map(sequence => {\n    let seq = [];\n    const len = all ? sequence.length() : sequence.length() - 1;\n\n    for (let j = 0; j < len; j++) {\n      seq.push(substringsToPattern(sequence.substrs[j] || '', min_replacement));\n    }\n\n    return sequencePattern(seq);\n  }));\n};\n/**\n * Return true if the sequence is already in the sequences\n * @param {Sequence} needle_seq\n * @param {Sequence[]} sequences\n */\n\n\nconst inSequences = (needle_seq, sequences) => {\n  for (const seq of sequences) {\n    if (seq.start != needle_seq.start || seq.end != needle_seq.end) {\n      continue;\n    }\n\n    if (seq.substrs.join('') !== needle_seq.substrs.join('')) {\n      continue;\n    }\n\n    let needle_parts = needle_seq.parts;\n    /**\n     * @param {TSequencePart} part\n     */\n\n    const filter = part => {\n      for (const needle_part of needle_parts) {\n        if (needle_part.start === part.start && needle_part.substr === part.substr) {\n          return false;\n        }\n\n        if (part.length == 1 || needle_part.length == 1) {\n          continue;\n        } // check for overlapping parts\n        // a = ['::=','==']\n        // b = ['::','===']\n        // a = ['r','sm']\n        // b = ['rs','m']\n\n\n        if (part.start < needle_part.start && part.end > needle_part.start) {\n          return true;\n        }\n\n        if (needle_part.start < part.start && needle_part.end > part.start) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    let filtered = seq.parts.filter(filter);\n\n    if (filtered.length > 0) {\n      continue;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nclass Sequence {\n  constructor() {\n    /** @type {TSequencePart[]} */\n    this.parts = [];\n    /** @type {string[]} */\n\n    this.substrs = [];\n    this.start = 0;\n    this.end = 0;\n  }\n  /**\n   * @param {TSequencePart|undefined} part\n   */\n\n\n  add(part) {\n    if (part) {\n      this.parts.push(part);\n      this.substrs.push(part.substr);\n      this.start = Math.min(part.start, this.start);\n      this.end = Math.max(part.end, this.end);\n    }\n  }\n\n  last() {\n    return this.parts[this.parts.length - 1];\n  }\n\n  length() {\n    return this.parts.length;\n  }\n  /**\n   * @param {number} position\n   * @param {TSequencePart} last_piece\n   */\n\n\n  clone(position, last_piece) {\n    let clone = new Sequence();\n    let parts = JSON.parse(JSON.stringify(this.parts));\n    let last_part = parts.pop();\n\n    for (const part of parts) {\n      clone.add(part);\n    }\n\n    let last_substr = last_piece.substr.substring(0, position - last_part.start);\n    let clone_last_len = last_substr.length;\n    clone.add({\n      start: last_part.start,\n      end: last_part.start + clone_last_len,\n      length: clone_last_len,\n      substr: last_substr\n    });\n    return clone;\n  }\n\n}\n/**\n * Expand a regular expression pattern to include unicode variants\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n * Issue:\n *  ﺊﺋ [ 'ﺊ = \\\\u{fe8a}', 'ﺋ = \\\\u{fe8b}' ]\n *\tbecomes:\tئئ [ 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}', 'ي = \\\\u{64a}', 'ٔ = \\\\u{654}' ]\n *\n *\tİĲ = IIJ = ⅡJ\n *\n * \t1/2/4\n *\n * @param {string} str\n * @return {string|undefined}\n */\n\n\nconst getPattern = str => {\n  initialize();\n  str = asciifold(str);\n  let pattern = '';\n  let sequences = [new Sequence()];\n\n  for (let i = 0; i < str.length; i++) {\n    let substr = str.substring(i);\n    let match = substr.match(multi_char_reg);\n    const char = str.substring(i, i + 1);\n    const match_str = match ? match[0] : null; // loop through sequences\n    // add either the char or multi_match\n\n    let overlapping = [];\n    let added_types = new Set();\n\n    for (const sequence of sequences) {\n      const last_piece = sequence.last();\n\n      if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {\n        // if we have a multi match\n        if (match_str) {\n          const len = match_str.length;\n          sequence.add({\n            start: i,\n            end: i + len,\n            length: len,\n            substr: match_str\n          });\n          added_types.add('1');\n        } else {\n          sequence.add({\n            start: i,\n            end: i + 1,\n            length: 1,\n            substr: char\n          });\n          added_types.add('2');\n        }\n      } else if (match_str) {\n        let clone = sequence.clone(i, last_piece);\n        const len = match_str.length;\n        clone.add({\n          start: i,\n          end: i + len,\n          length: len,\n          substr: match_str\n        });\n        overlapping.push(clone);\n      } else {\n        // don't add char\n        // adding would create invalid patterns: 234 => [2,34,4]\n        added_types.add('3');\n      }\n    } // if we have overlapping\n\n\n    if (overlapping.length > 0) {\n      // ['ii','iii'] before ['i','i','iii']\n      overlapping = overlapping.sort((a, b) => {\n        return a.length() - b.length();\n      });\n\n      for (let clone of overlapping) {\n        // don't add if we already have an equivalent sequence\n        if (inSequences(clone, sequences)) {\n          continue;\n        }\n\n        sequences.push(clone);\n      }\n\n      continue;\n    } // if we haven't done anything unique\n    // clean up the patterns\n    // helps keep patterns smaller\n    // if str = 'r₨㎧aarss', pattern will be 446 instead of 655\n\n\n    if (i > 0 && added_types.size == 1 && !added_types.has('3')) {\n      pattern += sequencesToPattern(sequences, false);\n      let new_seq = new Sequence();\n      const old_seq = sequences[0];\n\n      if (old_seq) {\n        new_seq.add(old_seq.last());\n      }\n\n      sequences = [new_seq];\n    }\n  }\n\n  pattern += sequencesToPattern(sequences, true);\n  return pattern;\n};\n\nexport { _asciifold, asciifold, code_points, generateMap, generateSets, generator, getPattern, initialize, mapSequence, normalize, substringsToPattern, unicode_map };\n//# sourceMappingURL=index.js.map\n"],"names":["code_points","accent_pat","max_char_length","latin_convert","latin_condensed","unicode","i","char","convert_pat","Object","initialize","_code_points","unicode_map","generateMap","normalize","form","str","asciifold","result","_asciifold","composed","String","folded","code_point","generateSets","unicode_sets","addMatching","folded_set","patt","setToPattern","to_add","escape_regex","generator","value","multi_char","set","b","a","multi_char_patt","arrayToPattern","multi_char_reg","mapSequence","min_replacement","chars_replaced","strings","sequencePattern","substringsToPattern","Math","sub_pat","sequencesToPattern","all","sequences","sequence","seq","len","j","inSequences","needle_seq","needle_parts","filter","part","needle_part","filtered","constructor","add","last","length","clone","parts","JSON","last_part","last_substr","last_piece","position","clone_last_len","start","end","substr","getPattern","pattern","match","match_str","overlapping","added_types","new_seq","old_seq"],"mappings":"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"}